---
title: "Similarity between two groups of terms"
author: "Zuguang Gu ( z.gu@dkfz.de )"
date: '`r Sys.Date()`'
output: html_document
vignette: >
  %\VignetteIndexEntry{6. Similarity between two groups of terms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    warning = FALSE,
    fig.align = "center")
```



The methods of semantic similarity implemented in **simone** are mainly from
the [supplementary file](https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/bib/18/5/10.1093_bib_bbw067/2/bbw067_supplementary_file.pdf?Expires=1692176766&Signature=Ks4C96x-kinySVP7rzVzMn8cGnQWXOqkB-6gYHhs48Bl9A2Vj~-mcI9pEnvntNBvjBD1hp4ZncMWUNT-y1ArrrQgDJ0dCCEJp5LG0Ag2oPWsC5NFEeUQiYNZCXal8Kwa3Ze1vtDHjIwZpT9-sZhn9ryqKHd3C88RvuGx10jcSYRL1Pec0F~a9CnrbivieCfFELg2OQTf5zpAobxhlqzWqv~sa1b62PunNZ~XkmnTGOJoSMQFnNaBy~bDNEf9Pd6eRYaOc8MUh5Br4xB4y8mivT6Et2vKzLrGJFQjYpvouQpBu0nf03xwHVmNFN5-6LsDnpyQPCy4nQ5DHYltVHkEOA__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA)
of the paper ["Mazandu et al., Gene Ontology semantic similarity tools: survey
on features and challenges for biological knowledge discovery. Briefings in
Bioinformatics 2017"](https://doi.org/10.1093/bib/bbw067). Original
denotations have been slightly modified to make them more consistent. Also
more explanations have been added in this vignette. Credits go to
the original paper.


There are two groups of terms denoted as $T_p$ and $T_q$ represented as two sets:

$$ T_p = \{ a_1, a_2, ...\} \\
   T_q = \{ b_1, b_2, ... \} $$

where $a_i$ is a term in set $T_p$ and $b_j$ is a term in set $T_q$.


The wrapper function `group_sim()` calculates semantic similarities between two groups
of terms with a specific method. Note the method name can be partially matched.


```r
group_sim(dag, group1, group2, method = ..., control = list(...))
```

Some of the group similarity methods have no assumption of which similarity
measure between single terms to use. If there are annotation already provided
in the DAG object, by default *Sim_Lin_1998* is used, or else *Sim_WP_1994* is
used. The term similarity method can be set via the `term_sim_method`
parameter in `control`.

```r
group_sim(dag, group1, group2, method = ..., 
    control = list(term_sim_method = ...))
```

## GroupSim_pairwise_avg

Denote $S(a, b)$ as the semantic similarity between term $a$ and $b$ where $a$
is from group $p$ and $b$ is from group $q$, The similarity between group $p$
and group $q$ is the average similarity of every pair of individual terms in
the two groups:

$$ \mathrm{GroupSim}(p, q) = \frac{1}{|T_p|*|T_q|} \sum_{a \in T_p, b \in T_q}S(a, b) $$

```r
group_sim(dag, group1, group2, method = "GroupSim_pairwise_avg",
    control = list(term_sim_method = ...))
```

## GroupSim_pairwise_max
This is the maximal S(a, b) among all pairs of terms in group1 and group2:

$$ \mathrm{GroupSim}(p, q) = \max_{a \in T_p, b \in T_q}S(a, b) $$


group_sim = max_{a in group1, b in group2}(S(a, b))
The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_BMA
BMA stands for "best-match average". First define similarity of a term to a group of terms as

$$ S(x, T) = \max_{y \in T} S(x, y) $$

S(x, group) = max_{y in group}(x, y)
which is the most similar terms in group to x.

Then the BMA similarity is calculated as:

$$ \mathrm{GroupSim}(p, q) = \frac{1}{2}\left( \frac{1}{|T_p|}\sum_{a \in T_p} S(a, T_q) + \frac{1}{|T_q|}\sum_{b \in T_q} S(b, T_p) \right) $$


So it is the average of the similarity of every term in group1 to the whole group2 and every term in group2 to the whole group1.

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_BMM
BMM stands for "best-match max". It is defined as:

$$ \mathrm{GroupSim}(p, q) = \max \left \{ \frac{1}{|T_p|}\sum_{a \in T_p} S(a, T_q), \frac{1}{|T_q|}\sum_{b \in T_q} S(b, T_p) \right \} $$


The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_ABM
ABM stands for "average best-match". It is defined as:

group_sim = (sum_{a in group1}(S(a, group2)) + sum_{b in group2}(S(b, group1)))/(n1 + n2)

$$ \mathrm{GroupSim}(p, q) = \frac{1}{|T_q| + |T_q|} \left( \sum_{a \in T_p} S(a, T_q) + \sum_{b \in T_q} S(b, T_p) \right)  $$

where n1 and n2 are the number of terms in group1 and group2.

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_HDF
First define the distance of a term to a group of terms:

D(x, group) = 1 - S(x, group)

$$D(x, T) = 1 - S(x, T)$$

Then the Hausdorff distance between two groups are:

$$ \mathrm{HDF}(p, q) = \max \left\{ \max_{a \in T_p} D(a, T_q), \max_{b \in T_q} D(b, T_q) \right\} $$

HDF = max(max_{a in group1}(D(a, group2)), max_{b in group2}(D(b, group1)))
This final similarity is:

group_sim = 1 - HDF

$$ \mathrm{GroupSim}(p, q) = 1 - \mathrm{HDF}(p, q) $$

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_MHDF
Instead of using the maximal distance from a group to the other group, MHDF uses mean distance:

MHDF = max(mean_{a in group1}(D(a, group2)), mean_{b in group2}(D(b, group1)))

$$ \mathrm{MHDF}(p, q) = \max \left\{ \frac{1}{|T_p|} \sum_{a \in T_p} D(a, T_q), \frac{1}{|T_q|} \sum_{b \in T_q} D(b, T_q) \right\} $$


This final similarity is:

$$ \mathrm{GroupSim}(p, q) = 1 - \mathrm{MHDF}(p, q) $$

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_VHDF
It is defined as:

VHDF = 0.5*(sqrt(mean_{a in group1}(D(a, group2)^2)) + sqrt(mean_{b in group2}(D(b, group1)^2)))


$$ \mathrm{VHDF}(p, q) = \frac{1}{2} \left\( \sqrt{\frac{1}{|T_p|} \sum_{a \in T_p} D^2(a, T_q)} + \sqrt{\frac{1}{|T_q|} \sum_{b \in T_q} D^2(b, T_q)} \right\) $$


$$ \mathrm{GroupSim}(p, q) = 1 - \mathrm{VHDF}(p, q) $$

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_Froehlich_2007
The similarity is:

group_sim = exp(-HDF(group1, group2))

$$ \mathrm{GroupSim}(p, q) = \exp(-\mathrm{HDF}(p, q)) $$

The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_pairwise_Joeng_2014
Similar to VHDF, but it directly uses the similarity:

$$ \mathrm{GroupSim}(p, q) = \frac{1}{2} \left\( \sqrt{\frac{1}{|T_p|} \sum_{a \in T_p} S^2(a, T_q)} + \sqrt{\frac{1}{|T_q|} \sum_{b \in T_q} S^2(b, T_q)} \right\) $$


The term semantic similarity method can be set via control = list(term_sim_method = ...).

## GroupSim_SimALN
It is based on the average distances between every pair of terms in the two groups:

exp(-mean_{a in group1, b in group2}(d(a, b)))

$$ \mathrm{GroupSim}(p, q) = \exp\left(-\frac{1}{|T_p|*|T_q|} \sum_{a \in T_p, b \in T_q} D_\mathrm{sp}(a, b)\right) $$


$$ \mathrm{GroupSim}(p, q) = \exp\left(-\frac{1}{|T_p|*|T_q|} \sum_{a \in T_p, b \in T_q} \mathrm{len}(a, b)\right) $$

d(a, b) is the distance between a and b, which can be the shortest distance between the two terms or the longest distnace via LCA.

Distance method can be set via control = list(distance = ...).

## GroupSim_SimINT
To be added.

## GroupSim_spgk
To be added.

## GroupSim_SimGIC

Denote $A$ and $B$ as the two sets of ancestors terms of terms in group1 and group2 respectively, the SimGIC is:


$$
\begin{align*}
 \mathcal{A}_p &= \bigcup_{a \in T_p} \mathcal{A}_a \\
 \mathcal{A}_q &= \bigcup_{b \in T_q} \mathcal{A}_b \\
\end{align*}
$$


$$ \mathrm{GroupSim}(p, q) = \frac{\sum\limits_{x \in \mathcal{A}_p \cap \mathcal{A}_q} \mathrm{IC}(x)}{\sum\limits_{x \in \mathcal{A}_p \cup \mathcal{A}_q} \mathrm{IC}(x)}  $$

group_sim = sum_{x in intersect(A, B)}(IC(x))/sum_{x in union(A, B)}(IC(x))
IC method can be set via control = list(IC_method = ...).

## GroupSim_SimDIC
Similar as GroupSim_SimGIC, it calculates the Dice coeffcient:

IC method can be set via control = list(IC_method = ...).

$$ \mathrm{GroupSim}(p, q) = \frac{2 * \sum\limits_{x \in \mathcal{A}_p \cap \mathcal{A}_q} \mathrm{IC}(x)}{\sum\limits_{x \in \mathcal{A}_p} \mathrm{IC}(x) + \sum\limits_{x \in \mathcal{A}_q} \mathrm{IC}(x)}  $$


## GroupSim_SimUIC
Similar as GroupSim_SimGIC, it is calculated as:

$$ \mathrm{GroupSim}(p, q) = \frac{2 * \sum\limits_{x \in \mathcal{A}_p \cap \mathcal{A}_q} \mathrm{IC}(x)}{\max\left\{\sum\limits_{x \in \mathcal{A}_p} \mathrm{IC}(x), \sum\limits_{x \in \mathcal{A}_q} \mathrm{IC}(x) \right\}}  $$

IC method can be set via control = list(IC_method = ...).

## GroupSim_SimUI
It is only based on the number of terms. A is the set of all ancestors of group1 terms and B is the set of all ancestors of group2 terms.


$$ \mathrm{GroupSim}(p, q) = \frac{|\mathcal{A}_p \cap \mathcal{A}_q|}{|\mathcal{A}_p \cup \mathcal{A}_q|} $$

## GroupSim_SimDB
It is:

$$ \mathrm{GroupSim}(p, q) = \frac{2*|\mathcal{A}_p \cap \mathcal{A}_q|}{|\mathcal{A}_p| +  |\mathcal{A}_q|} $$

## GroupSim_SimUB
It is:

$$ \mathrm{GroupSim}(p, q) = \frac{|\mathcal{A}_p \cap \mathcal{A}_q|}{\max\{|\mathcal{A}_p|,  |\mathcal{A}_q|\}} $$

## GroupSim_SimNTO
It is:

$$ \mathrm{GroupSim}(p, q) = \frac{|\mathcal{A}_p \cap \mathcal{A}_q|}{\min\{|\mathcal{A}_p|,  |\mathcal{A}_q|\}} $$

## GroupSim_SimCOU

It is based on the dot product of two vectors p and q which correspond to terms in group1 and group2. p and q have the same length as the total number of terms. Value of position i in p or q corresponds to term t. The value takes IC(t) if t is an ancestor of any term in p or q, and the value takes zero if t is not. The similarity betweem group1 terms and group2 terms is calculated as:

<p,q>/||p||/||q||
where <p,q> is the dot product between the two, and ||p|| or ||q|| is the norm of the vector. The equation can be written as:

group_sim = sum_{x in intersect(A, B)}(IC(x)^2) / 
              sqrt(sum_{x in A}(IC(x)^2)) / 
              sqrt(sum_{x in B}(IC(x)^2))
IC method can be set via control = list(IC_method = ...).

## GroupSim_SimCOT

Similar as GroupSim_SimCOU, the similarity is:

<p,q>/(||p||^2 + ||q||^2 - <p,q>)
And it can be rewritten as:

group_sim = sum_{x in intersect(A, B)}(IC(x)^2) /
    (sum_{x in A}(IC(x)^2) + sum_{x in B}(IC(x)^2) - sum_{x in intersect(A, B)}(IC(x)^2))
IC method can be set via control = list(IC_method = ...).

## GroupSim_SimLP

It is the longest depth for the terms in intersect(A, B).

$$ \mathrm{GroupSim}(p, q) = \max\{\delta(t): t \in \mathcal{A}_p \cap \mathcal{A}_q\} $$

## GroupSim_Ye_2005
It is a normalized version of *GroupSim_SimLP*:

$$
\begin{align*}
\mathrm{GroupSim}(p, q) &= \max\left\{\frac{\delta(t) - \delta_\mathrm{min}}{\delta_\mathrm{max} - \delta_\mathrm{min}}: t \in \mathcal{A}_p \cap \mathcal{A}_q\right\} \\
    &= \max\left\{\frac{\delta(t) }{\delta_\mathrm{max}}: t \in \mathcal{A}_p \cap \mathcal{A}_q\right\}
\end{align*}
$$

Since the minimal depth is zero for root.

## GroupSim_SimCHO
It is based on the annotated items. Denote sigma(t) as the total annotated items of t. The similarity is calculated as

$$
\begin{align*}
\mathrm{GroupSim}(p, q) &= \frac{\max\limits_{x \in T_p \cup T_q}\mathrm{IC}(x)}{\mathrm{IC}_\mathrm{max}}
\end{align*}
$$

group_sim = log(C/sigma_max)/log(sigma_min/sigma_max)
where C is min(sigma_{x in intersect(A, B)}(x)), i.e., the minimal sigma in the intersection of group1 and group2. Note Now A and B are just two sets of terms in group1 and group2. sigma_max is the total number of items annotated to the DAG, sig_min is the minimal number of items annotated to a term, which is mostly 1.

## GroupSim_SimALD
A and B are just two sets of terms in group1 and group2. The similarity is calculated as:

$$ \mathrm{GroupSim}(p, q) = \max\left\{ 1 - \frac{n(x)}{N}: x \in T_p \cap T_q \right\} $$

group_sim = max_{t in intersect(A, B)}(1 - sigma(t)/N)

## GroupSim_Jaccard
Say A is the set of items annotated to terms in group1 and B is the set of items annotated to group2. This is the Jaccard coeffcient between two sets.

The universe/background can be set via control = list(universe = ...).

## GroupSim_Dice
It is the Dice coeffcient between A and B.

The universe/background can be set via control = list(universe = ...).

## GroupSim_Overlap
It is the Overlap coeffcient between A and B.

The universe/background can be set via control = list(universe = ...).

## GroupSim_Kappa
The universe/background can be set via control = list(universe = ...).