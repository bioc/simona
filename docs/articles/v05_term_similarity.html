<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Term similarity • simona</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Term similarity">
<meta property="og:description" content="simona">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">simona</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.1.6</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/v01_dag.html">ontology_DAG: a class for ontology data</a>
    </li>
    <li>
      <a href="../articles/v02_GO.html">Gene Ontology</a>
    </li>
    <li>
      <a href="../articles/v03_import.html">Import ontology files</a>
    </li>
    <li>
      <a href="../articles/v04_information_content.html">Information content</a>
    </li>
    <li>
      <a href="../articles/v05_term_similarity.html">Term similarity</a>
    </li>
    <li>
      <a href="../articles/v06_group_similarity.html">Similarity between two groups of terms</a>
    </li>
    <li>
      <a href="../articles/v07_dag_visualization.html">Visualize DAGs</a>
    </li>
    <li>
      <a href="../articles/v08_random.html">Random DAGs</a>
    </li>
    <li>
      <a href="../articles/v09_shiny.html">Shiny app</a>
    </li>
    <li>
      <a href="../articles/v10_enrichment.html">Functional enrichment</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/jokergoo/simona/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Term similarity</h1>
                        <h4 data-toc-skip class="author">Zuguang Gu ( <a href="mailto:z.gu@dkfz.de" class="email">z.gu@dkfz.de</a> )</h4>
            
            <h4 data-toc-skip class="date">2023-12-14</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jokergoo/simona/blob/HEAD/vignettes/v05_term_similarity.Rmd" class="external-link"><code>vignettes/v05_term_similarity.Rmd</code></a></small>
      <div class="hidden name"><code>v05_term_similarity.Rmd</code></div>

    </div>

    
    
<p>The methods of semantic similarity implemented in <strong>simona</strong> are mainly from the <a href="https://academic.oup.com/bib/article/18/5/886/2562801#supplementary-data" class="external-link">supplementary file</a> of the paper <a href="https://doi.org/10.1093/bib/bbw067" class="external-link">“Mazandu et al., Gene Ontology semantic similarity tools: survey on features and challenges for biological knowledge discovery. Briefings in Bioinformatics 2017”</a>. Original denotations have been slightly modified to make them more consistent. Also more explanations have been added in this vignette.</p>
<div class="section level3">
<h3 id="denotations">Denotations<a class="anchor" aria-label="anchor" href="#denotations"></a>
</h3>
<p>The following denotations will be used throughout the vignette. The denotations are mainly from <em>Mazandu 2017</em> only with small modifications.</p>
<table class="table">
<colgroup>
<col width="19%">
<col width="80%">
</colgroup>
<thead><tr class="header">
<th align="left">Denotation</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(r\)</span></td>
<td align="left">The root term of the DAG. In <strong>simona</strong> there is always one root term.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\delta(x)\)</span></td>
<td align="left">The depth of a term <span class="math inline">\(x\)</span> in the DAG, which is the longest distance from root <span class="math inline">\(r\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\delta_s(x)\)</span></td>
<td align="left">The length of the longest path from root <span class="math inline">\(r\)</span> to a term <span class="math inline">\(x\)</span> via term <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\delta_\max\)</span></td>
<td align="left">The maximal depth in the DAG.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\eta(x)\)</span></td>
<td align="left">The height of term <span class="math inline">\(x\)</span> in the DAG, which is the longest finite distance to leaf terms.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathcal{C}_s\)</span></td>
<td align="left">The set of child terms of term <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathcal{P}_s\)</span></td>
<td align="left">The set of parent terms of term <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathcal{A}_s\)</span></td>
<td align="left">The set of ancestor terms of term <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathcal{A}_s^+\)</span></td>
<td align="left">The set of ancestor terms of term <span class="math inline">\(s\)</span>, including <span class="math inline">\(s\)</span> itself.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathcal{D}_s\)</span></td>
<td align="left">The set of offspring terms of term <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathcal{D}_s^+\)</span></td>
<td align="left">The set of offspring terms of term <span class="math inline">\(s\)</span>, including <span class="math inline">\(s\)</span> itself.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathcal{L}_s\)</span></td>
<td align="left">The set of leaf terms that term <span class="math inline">\(s\)</span> can reach.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\left| A \right|\)</span></td>
<td align="left">Number of elements in set <span class="math inline">\(A\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(D_\mathrm{sp}(a, b)\)</span></td>
<td align="left">The shortest distance bewteen <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathrm{len}(a, b)\)</span></td>
<td align="left">The longest distance bewteen <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathrm{len}_s(a, b)\)</span></td>
<td align="left">The length of the longest path from <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via <span class="math inline">\(s\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathrm{CA}(a, b)\)</span></td>
<td align="left">The set of common ancestors of term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, i.e. <span class="math inline">\(\mathrm{CA}(a, b) = \mathcal{A}_a^+ \cap \mathcal{A}_b^+\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathrm{LCA}(a, b)\)</span></td>
<td align="left">Lowest common ancestor of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, which is the common ancestor with the largest depth in DAG, i.e. <span class="math display">\[\operatorname*{argmax}_{t \in \mathrm{CA}(a, b)} \delta(t)\]</span> There might be more than one LCA terms for given two terms, to simplify the calculation, the one with the longest distance (the default) to <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is used.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mathrm{NCA}(a, b)\)</span></td>
<td align="left">Nearest common ancestor of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, i.e. <span class="math display">\[\operatorname*{argmin}_{t \in \mathrm{CA}(a, b)} \left( D_\mathrm{sp}(t, a) + D_\mathrm{sp}(t, b) \right)\]</span> If there are more than one NCA terms, the one with the largest depth (the lowest one) is used.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathrm{MICA}(a, b)\)</span></td>
<td align="left">Most informative common ancestor of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, i.e. <span class="math display">\[\operatorname*{argmax}_{t \in \mathrm{CA}(a, b)} \left( \mathrm{IC}(t) \right )\]</span> There might be more than one MICA terms for given two terms, the one with the longest distance (the default) to <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is used.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(G_s\)</span></td>
<td align="left">The set of annotated items on term <span class="math inline">\(s\)</span>.</td>
</tr>
</tbody>
</table>
<p>Assume term <span class="math inline">\(a\)</span> is an ancestor of term <span class="math inline">\(b\)</span>, <span class="math inline">\(D_\mathrm{sp}(a, b)\)</span> (the order of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> does not matter) is the normal shortest distance from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> in a directed graph. The definition is similar for <span class="math inline">\(\mathrm{len}(a, b)\)</span>.</p>
<p>If term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are not in offspring/ancestor relationship, i.e. <span class="math inline">\(a\)</span> is not an ancestor of <span class="math inline">\(b\)</span>, and <span class="math inline">\(b\)</span> is not an ancestor of <span class="math inline">\(a\)</span>, then</p>
<p><span class="math display">\[
\begin{align*}
D_\mathrm{sp}(a, b) &amp;= \min_{t \in \mathrm{CA}(a, b)} \left( D_\mathrm{sp}(t, a) + D_\mathrm{sp}(t, b) \right) \\
\mathrm{len}(a, b) &amp;= \max_{t \in \mathrm{CA}(a, b)} \left( \mathrm{len}(t, a) + \mathrm{len}(t, b) \right)
\end{align*}
\]</span></p>
</div>
<div class="section level3">
<h3 id="general">General<a class="anchor" aria-label="anchor" href="#general"></a>
</h3>
<p>The wrapper function <code><a href="../reference/term_sim.html">term_sim()</a></code> calculates semantic similarities between terms in the DAG with a specific method. Note the method name can be partially matched. <code>control</code> argument controls parameters for specific methods.</p>
<pre class="r">
term_sim(dag, terms, method = ..., control = list(...))
</pre>
<p>All supported term similarity methods are:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jokergoo/simona" class="external-link">simona</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/all_methods.html">all_term_sim_methods</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] "Sim_Lin_1998"         "Sim_Resnik_1999"      "Sim_FaITH_2010"      </span></span>
<span><span class="co">##  [4] "Sim_Relevance_2006"   "Sim_SimIC_2010"       "Sim_XGraSM_2013"     </span></span>
<span><span class="co">##  [7] "Sim_EISI_2015"        "Sim_AIC_2014"         "Sim_Zhang_2006"      </span></span>
<span><span class="co">## [10] "Sim_universal"        "Sim_Wang_2007"        "Sim_GOGO_2018"       </span></span>
<span><span class="co">## [13] "Sim_Rada_1989"        "Sim_Resnik_edge_2005" "Sim_Leocock_1998"    </span></span>
<span><span class="co">## [16] "Sim_WP_1994"          "Sim_Slimani_2006"     "Sim_Shenoy_2012"     </span></span>
<span><span class="co">## [19] "Sim_Pekar_2002"       "Sim_Stojanovic_2001"  "Sim_Wang_edge_2012"  </span></span>
<span><span class="co">## [22] "Sim_Zhong_2002"       "Sim_AlMubaid_2006"    "Sim_Li_2003"         </span></span>
<span><span class="co">## [25] "Sim_RSS_2013"         "Sim_HRSS_2013"        "Sim_Shen_2010"       </span></span>
<span><span class="co">## [28] "Sim_SSDD_2013"        "Sim_Jiang_1997"       "Sim_Kappa"           </span></span>
<span><span class="co">## [31] "Sim_Jaccard"          "Sim_Dice"             "Sim_Overlap"         </span></span>
<span><span class="co">## [34] "Sim_Ancestor"</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="ic-based-or-node-based-methods">IC-based or node-based methods<a class="anchor" aria-label="anchor" href="#ic-based-or-node-based-methods"></a>
</h3>
<p>This type of methods consider a special ancestor term <span class="math inline">\(c\)</span> of terms <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, which has the highest IC among all <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>’s ancestor terms. Term <span class="math inline">\(c\)</span> is called the most informative common ancestor (MICA) which can be given by:</p>
<p><span class="math display">\[ \mathrm{IC}(c) = \max_{t \in \mathcal{A}_a^+ \cap \mathcal{A}_b^+} \mathrm{IC}(t)  \]</span></p>
<p>So if two terms are identical, MICA is the term itself, and if two terms have ancestor/offspring relationship, MICA is the ancestor term.</p>
<p>In the following sections, if not specially mentioned, <span class="math inline">\(c\)</span> is always referred to the MICA of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<div class="section level4">
<h4 id="sim_lin_1998">Sim_Lin_1998<a class="anchor" aria-label="anchor" href="#sim_lin_1998"></a>
</h4>
<p>The similarity is calculated as the IC of the MICA term <span class="math inline">\(c\)</span> normalized by the average of the IC of the two terms:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(c)}{(\mathrm{IC}(a) + \mathrm{IC}(b))/2} = \frac{2 * \mathrm{IC}(c)}{\mathrm{IC}(a) + \mathrm{IC}(b)} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Lin_1998")
</pre>
<p>Paper link: <a href="https://dl.acm.org/doi/10.5555/645527.657297" class="external-link uri">https://dl.acm.org/doi/10.5555/645527.657297</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_resnik_1999">Sim_Resnik_1999<a class="anchor" aria-label="anchor" href="#sim_resnik_1999"></a>
</h4>
<p>IC of the MICA term itself <span class="math inline">\(\mathrm{IC}(c)\)</span> can be a measure of how similar two terms are, but its range is not in <code>[0, 1]</code>. There are several ways to normalize <span class="math inline">\(\mathrm{IC}(c)\)</span> to the range of <code>[0, 1]</code>. Note some of the normalization methods are restricted to <em>IC_annotation</em> as the IC method.</p>
<div class="section level5">
<h5 id="nunif">Nunif<a class="anchor" aria-label="anchor" href="#nunif"></a>
</h5>
<p>It is normalized to the possible maximal IC value where a term only has one item annotated.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(c)}{-\log(1/N)} = \frac{\mathrm{IC}(c)}{\log N} \]</span></p>
<p>where <span class="math inline">\(N\)</span> is the total number of items annotated to the whole DAG.</p>
</div>
<div class="section level5">
<h5 id="nmax">Nmax<a class="anchor" aria-label="anchor" href="#nmax"></a>
</h5>
<p>It is similar to <em>Nunif</em>, but normalized to the maximal IC of all terms in the DAG. If there is a term with only one item annotated, <em>Nmax</em> is identical to the <em>Nunif</em> method.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(c)}{\mathrm{IC}_\mathrm{max}} \]</span></p>
</div>
<div class="section level5">
<h5 id="nunivers">Nunivers<a class="anchor" aria-label="anchor" href="#nunivers"></a>
</h5>
<p><span class="math inline">\(\mathrm{IC}(c)\)</span> is normalized by the maximal IC of term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(c)}{\max \{ \mathrm{IC}(a), \mathrm{IC}(b) \}} \]</span></p>
<p>Paper link: <a href="https://doi.org/10.1613/jair.514" class="external-link uri">https://doi.org/10.1613/jair.514</a>, <a href="https://doi.org/10.1186/1471-2105-9-S5-S4" class="external-link uri">https://doi.org/10.1186/1471-2105-9-S5-S4</a>, <a href="https://doi.org/10.1186/1471-2105-11-562" class="external-link uri">https://doi.org/10.1186/1471-2105-11-562</a>, <a href="https://doi.org/10.1155/2013/292063" class="external-link uri">https://doi.org/10.1155/2013/292063</a>.</p>
<p>The normalization method can be set with the <code>norm_method</code> parameter:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Resnik_1999", control = list(norm_method = "Nunif"))
term_sim(dag, terms, method = "Sim_Resnik_1999", control = list(norm_method = "Nmax"))
term_sim(dag, terms, method = "Sim_Resnik_1999", control = list(norm_method = "Nunivers"))
</pre>
</div>
</div>
<div class="section level4">
<h4 id="sim_faith_2010">Sim_FaITH_2010<a class="anchor" aria-label="anchor" href="#sim_faith_2010"></a>
</h4>
<p>It is calculated as:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(c)}{\mathrm{IC}(a) + \mathrm{IC}(b) - \mathrm{IC}(c)} \]</span></p>
<p>The relation between the <em>FaITH_2010</em> similarity and <em>Lin_1998</em> similarity is:</p>
<p><span class="math display">\[ \mathrm{Sim}_\mathrm{FaITH} = \frac{\mathrm{Sim}_\mathrm{Lin}}{2 - \mathrm{Sim}_\mathrm{Lin}} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_FaITH_2010")
</pre>
<p>Paper link: <a href="https://doi.org/10.1007/978-3-642-17746-0_39" class="external-link uri">https://doi.org/10.1007/978-3-642-17746-0_39</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_relevance_2006">Sim_Relevance_2006<a class="anchor" aria-label="anchor" href="#sim_relevance_2006"></a>
</h4>
<p>If thinking <em>Lin_1998</em> is a measure of how close term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are to their MICA term <span class="math inline">\(c\)</span>, the relevance method corrects it by multiplying a factor which considers the specificity of how <span class="math inline">\(c\)</span> brings the information. The factor is calculated as <span class="math inline">\(1-p(c)\)</span> where <span class="math inline">\(p(c)\)</span> is the annotation-based probability <span class="math inline">\(p(c) = k/N\)</span> where <span class="math inline">\(k\)</span> is the number of items annotated to <span class="math inline">\(c\)</span> and <span class="math inline">\(N\)</span> is the total number of items annotated to the DAG. Then under the Relevance method, the corrected IC of <span class="math inline">\(c\)</span> is:</p>
<p><span class="math display">\[ \mathrm{IC}_\mathrm{corrected}(c) = (1-p(c)) * \mathrm{IC}(c) \]</span></p>
<p>If using <em>Lin_1998</em> as the similarity method, the corrected version Relevance similarity is:</p>
<p><span class="math display">\[ 
\begin{align*}
\mathrm{Sim}(a, b) &amp; = \frac{2*\mathrm{IC}_\mathrm{corrected}(c)}{\mathrm{IC}(a) + \mathrm{IC}(b)} \\
                   &amp; = (1-p(c)) * \frac{2 * \mathrm{IC}(c)}{\mathrm{IC}(a) + \mathrm{IC}(b)} \\
                   &amp; = (1-p(c)) * \mathrm{Sim}_\mathrm{Lin}(a, b)
\end{align*} \]</span></p>
<p>The term <span class="math inline">\(p(c)\)</span> requires that terms should be annotated to items. However, it can be extended to more general scenarios:</p>
<p><span class="math display">\[ \mathrm{IC}_\mathrm{corrected}(c) = \left(1 - \exp(-\mathrm{IC}(x))\right) * \mathrm{IC}(c) \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Relevance_2006")
</pre>
<p>Paper link: <a href="https://doi.org/10.1186/1471-2105-7-302" class="external-link uri">https://doi.org/10.1186/1471-2105-7-302</a></p>
</div>
<div class="section level4">
<h4 id="sim_simic_2010">Sim_SimIC_2010<a class="anchor" aria-label="anchor" href="#sim_simic_2010"></a>
</h4>
<p>The <em>SimIC_2010</em> method is an improved correction method of the Relevance method because the latter works badly when <span class="math inline">\(p(c)\)</span> is very small. E.g., when <span class="math inline">\(1-p(c)\)</span> is used as a correction factor, it cannot nicely distinguish <span class="math inline">\(p(c) = 0.01\)</span> and <span class="math inline">\(p(c) = 0.001\)</span> because for both <span class="math inline">\(1 - p(c)\)</span> are very close to 1.</p>
<p>The <em>SimIC_2010</em> correction factor for MICA term <span class="math inline">\(c\)</span> is:</p>
<p><span class="math display">\[ \mathrm{IC}_\mathrm{corrected}(c) = 1 - \frac{1}{1 - \log(p(c))} * \mathrm{IC}(c) \]</span></p>
<p>Then the similarity (if using <em>Lin_1998</em> as the original similarity method) is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \left( 1 - \frac{1}{1 - \log(p(c))} \right) * \mathrm{Sim}_\mathrm{Lin}(a, b) \]</span></p>
<p>Similarly, it can be generalized to:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\mathrm{IC}(x)}{1 + \mathrm{IC}(x)} * \mathrm{Sim}_\mathrm{Lin}(a, b) \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_SimIC_2010")
</pre>
<p>Paper link: <a href="https://doi.org/10.48550/arXiv.1001.0958" class="external-link uri">https://doi.org/10.48550/arXiv.1001.0958</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_xgrasm_2013">Sim_XGraSM_2013<a class="anchor" aria-label="anchor" href="#sim_xgrasm_2013"></a>
</h4>
<p>Being different from the <em>Relevance</em> and <em>SimIC_2010</em> methods that only use the IC of the MICA term, the <em>XGraSM_2013</em> method as well as the next method use IC of a subset of common ancestor terms of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, and it uses the mean IC of them. The subset of common ancestor may have different names for different methods.</p>
<p><em>XGraSM_2013</em> is the simplest one which uses informative common ancestors (ICA) where IC of the common ancestor is positive.</p>
<p><span class="math display">\[ \mathrm{ICA}(a, b) = \{c \in \mathcal{A}_a^+ \cap \mathcal{A}_b^+: \mathrm{IC}(c) &gt; 0\} \]</span></p>
<p>And mean IC among all ICA terms:</p>
<p><span class="math display">\[ \mathrm{IC}_\mathrm{mean} = \frac{1}{|\mathrm{ICA}(a, b)|} \sum_{\mathrm{t \in \mathrm{ICA}(a, b)}} \mathrm{IC}(t) \]</span></p>
<p>And applying <em>Lin_1998</em> method, the semantic similarity is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 2 * \frac{\mathrm{IC}_\mathrm{mean}}{\mathrm{IC}(a) + \mathrm{IC}(b)} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_XGraSM_2013")
</pre>
<p>Paper link: <a href="https://doi.org/10.1186/1471-2105-14-284" class="external-link uri">https://doi.org/10.1186/1471-2105-14-284</a></p>
</div>
<div class="section level4">
<h4 id="sim_eisi_2015">Sim_EISI_2015<a class="anchor" aria-label="anchor" href="#sim_eisi_2015"></a>
</h4>
<p>It selects a specific subset of common ancestors of terms <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It only selects a common ancestor <span class="math inline">\(c\)</span> which can reach <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> via one of its child terms that does not belong to the common ancestors (mutual exclusively in <span class="math inline">\(a\)</span>’s ancestors or in <span class="math inline">\(b\)</span>’s ancestors). The set of the selected common ancestors is called the exclusively inherited common ancestors (EICA).</p>
<p><span class="math display">\[ \mathrm{EICA}(a, b) = \{c \in \mathcal{A}_a \cap \mathcal{A}_b: \mathcal{C}_c \cap \left( (\mathcal{A}_a \cup \mathcal{A}_b) - (\mathcal{A}_a \cap \mathcal{A}_b) \neq \emptyset \right) \}  \]</span></p>
<p>And mean IC among all EICA terms:</p>
<p><span class="math display">\[ \mathrm{IC}_\mathrm{mean} = \frac{1}{|\mathrm{EICA}(a, b)|} \sum_{\mathrm{t \in \mathrm{EICA}(a, b)}} \mathrm{IC}(t) \]</span></p>
<p>And applying <em>Lin_1998</em> method, the semantic similarit is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 2 * \frac{\mathrm{IC}_\mathrm{mean}}{\mathrm{IC}(a) + \mathrm{IC}(b)} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_EISI_2015")
</pre>
<p>Paper link: <a href="https://doi.org/10.1016/j.gene.2014.12.062" class="external-link uri">https://doi.org/10.1016/j.gene.2014.12.062</a></p>
</div>
<div class="section level4">
<h4 id="sim_aic_2014">Sim_AIC_2014<a class="anchor" aria-label="anchor" href="#sim_aic_2014"></a>
</h4>
<p>It uses the aggregate information content from ancestors. First define the semantic weight denoted as <span class="math inline">\(S_w\)</span> of a term <span class="math inline">\(t\)</span> in the DAG:</p>
<p><span class="math display">\[ S_w(t) = \frac{1}{1 + \exp \left(-\frac{1}{\mathrm{IC}(t)} \right)} \]</span></p>
<p>Then the similarity is calculated as the fraction of aggegation from common ancestors and the average aggregation from ancestors of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> separately.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{2*\sum\limits_{t \in \mathcal{A}_a^+ \cap \mathcal{A}_b^+} S_w(t) }{ \sum\limits_{t \in \mathcal{A}_a^+} S_w(t) + \sum\limits_{t \in \mathcal{A}_b^+} S_w(t) }  \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_AIC_2014")
</pre>
<p>Paper link: <a href="https://doi.org/10.1109/tcbb.2013.176" class="external-link uri">https://doi.org/10.1109/tcbb.2013.176</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_zhang_2006">Sim_Zhang_2006<a class="anchor" aria-label="anchor" href="#sim_zhang_2006"></a>
</h4>
<p>It uses the <em>IC_Zhang_2006</em> IC method and uses <em>Lin_1998</em> similarity method to calculate similarities:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{2*\mathrm{IC}_\mathrm{Zhang}(c)}{\mathrm{IC}_\mathrm{Zhang}(a) + \mathrm{IC}_\mathrm{Zhang}(b)} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Zhang_2006")
</pre>
</div>
<div class="section level4">
<h4 id="sim_universal">Sim_universal<a class="anchor" aria-label="anchor" href="#sim_universal"></a>
</h4>
<p>It uses the <em>IC_universal</em> IC method and uses the <em>Nunivers</em> method to calculate similarities:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{2*\mathrm{IC}_\mathrm{Univers}(c)}{\max \{ \mathrm{IC}_\mathrm{Univers}(a), \mathrm{IC}_\mathrm{Univers}(b) \}} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_universal")
</pre>
</div>
<div class="section level4">
<h4 id="sim_wang_2007">Sim_Wang_2007<a class="anchor" aria-label="anchor" href="#sim_wang_2007"></a>
</h4>
<p>Similar as the <em>Sim_AIC_2014</em> method, it is also aggregation from ancestors, but it uses the “S-value” introduced in the <em>IC_Wang_2007</em> sectionn in <a href="v4_information_content.html">4. Information content</a>.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\sum\limits_{t \in \mathcal{A}_a^+ \cap \mathcal{A}_b^+} (S_a(t) + S_b(t)) }{ \sum\limits_{t \in \mathcal{A}_a^+} S_a(t) + \sum\limits_{t \in \mathcal{A}_b^+} S_b(t) }  \]</span></p>
<p>The contribution of different semantic relations can be set with the <code>contribution_factor</code> parameter. The value should be a named numeric vector where names should cover the relations defined in relations set in <code><a href="../reference/create_ontology_DAG.html">create_ontology_DAG()</a></code>. For example, if there are two relations “relation_a” and “relation_b” set in the DAG, the value for contribution_factor can be set as:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Wang_2007", 
    control = list(contribution_factor = c("relation_a" = 0.8, "relation_b" = 0.6)))
</pre>
<p>By default 0.8 is set for “is_a” and 0.6 for “part_of”.</p>
<p>If you are not sure what types of relations have been set, simply type the <code>dag</code> object. The relation types will be printed there.</p>
<p>Paper link: <a href="https://doi.org/10.1093/bioinformatics/btm087" class="external-link uri">https://doi.org/10.1093/bioinformatics/btm087</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_gogo_2018">Sim_GOGO_2018<a class="anchor" aria-label="anchor" href="#sim_gogo_2018"></a>
</h4>
<p>It is very similar as <em>Sim_Wang_2007</em> except there is a correction for the contribution factor. When calculating the “S-value” introduced in the <em>IC_Wang_2007</em> sectionn in <a href="v4_information_content.html">4. Information content</a>, for a parent and a child, the weight variable <span class="math inline">\(w_e\)</span> is directly determined by the relation type, e.g, 0.8 for “is_a”. In <em>Sim_GOGO_2018</em>, the number of child terms is also considered for <span class="math inline">\(w_e\)</span>:</p>
<p><span class="math display">\[ w_e = \frac{1}{c + |\mathcal{C}_t|} + w_0 \]</span></p>
<p>where <span class="math inline">\(|\mathcal{C}_t|\)</span> is the number of child terms of the parent <span class="math inline">\(t\)</span>, <span class="math inline">\(w_0\)</span> is the original contribution factor directly assigned for each relation type. <span class="math inline">\(c\)</span> is selected to ensure <span class="math inline">\(w_e \leq 1\)</span> (assuming minimal number of children is 1), which is normally:</p>
<p><span class="math display">\[ c = \frac{\max \{w_0\}}{1 - \max \{w_0\}} \]</span></p>
<p>By default, 0.4 is assigned for “is_a” and 0.3 is assigned for “part_of”, <span class="math inline">\(c\)</span> is set to 2/3 (solve <code>1 = 1/(c + 1) + 0.4</code>).</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_GOGO_2018", 
    control = list(contribution_factor = c("relation_a" = 0.4, "relation_b" = 0.3)))
</pre>
<p>Paper link: <a href="https://doi.org/10.1038/s41598-018-33219-y" class="external-link uri">https://doi.org/10.1038/s41598-018-33219-y</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_ancestor">Sim_Ancestor<a class="anchor" aria-label="anchor" href="#sim_ancestor"></a>
</h4>
<p>This is Jaccard-like coeffcient</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\left| \mathcal{A}^+_a \cap \mathcal{A}^+_b \right|}{\left| \mathcal{A}^+_a \cup \mathcal{A}^+_b \right|} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Ancestor")
</pre>
</div>
</div>
<div class="section level2">
<h2 id="edge-based-methods">Edge-based methods<a class="anchor" aria-label="anchor" href="#edge-based-methods"></a>
</h2>
<p>Methods introduced in this section relies on the distance between terms. Many methods are defined originally based on the shortest distance between two terms. This section extends them to also support their longest distance via the LCA term.</p>
<div class="section level4">
<h4 id="sim_rada_1989">Sim_Rada_1989<a class="anchor" aria-label="anchor" href="#sim_rada_1989"></a>
</h4>
<p>It is based on the distance between term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It is defined as:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{1}{1 + D_\mathrm{sp}(a, b)} \]</span></p>
<p>which is based on the shortest distance between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Optionally, the distance can also be the longest distance via the LCA term <span class="math inline">\(c\)</span>.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{1}{1 + \mathrm{len}_c(a, b)} = \frac{1}{1 + \mathrm{len}(c, a) + \mathrm{len}(c, b)} \]</span></p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Rada_1989",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1109/21.24528" class="external-link uri">https://doi.org/10.1109/21.24528</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_resnik_edge_2005">Sim_Resnik_edge_2005<a class="anchor" aria-label="anchor" href="#sim_resnik_edge_2005"></a>
</h4>
<p>It is a normalized distance:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{D_\mathrm{sp}(a, b)}{2*\delta_\mathrm{max}} \]</span></p>
<p>where <span class="math inline">\(2*\delta_\mathrm{max}\)</span> can be thought as the possible maximal distance between two terms in the DAG.</p>
<p>Similarly, the distance can also be the longest distance via LCA, then it is consistent with the definition of <span class="math inline">\(\delta_\mathrm{max}\)</span> which are both based on the longest distance.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{\mathrm{len}_c(a, b)}{2*\delta_\mathrm{max}} \]</span></p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Resnik_edge_2005",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1145/1097047.1097051" class="external-link uri">https://doi.org/10.1145/1097047.1097051</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_leocock_1998">Sim_Leocock_1998<a class="anchor" aria-label="anchor" href="#sim_leocock_1998"></a>
</h4>
<p>It is similar as the <em>Sim_Resnik_edge_2005</em> method, but it applies log-transformation on the distance and the depth:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{\log(D_\mathrm{sp}(a, b))}{\log(2*\delta_\mathrm{max})} \]</span></p>
<p>where <span class="math inline">\(2*\delta_\mathrm{max}\)</span> can be thought as the possible maximal distance between two terms in the DAG.</p>
<p>Similarly, the distance can also be the longest distance via LCA, then it is consistent with the definition of <span class="math inline">\(\delta_\mathrm{max}\)</span> which are both based on the longest distance.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{\log(\mathrm{len}_c(a, b))}{\log(2*\delta_\mathrm{max})} \]</span></p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Leocock_1998",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://ieeexplore.ieee.org/document/6287675" class="external-link uri">https://ieeexplore.ieee.org/document/6287675</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_wp_1994">Sim_WP_1994<a class="anchor" aria-label="anchor" href="#sim_wp_1994"></a>
</h4>
<p>It is based on the depth of the LCA term <span class="math inline">\(c\)</span> and the longest distance between term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via <span class="math inline">\(c\)</span>:</p>
<p><span class="math display">\[
\begin{align*}
 \mathrm{Sim}(a, b) &amp; = \frac{2*\delta(c)}{\mathrm{len}(c, a) + \mathrm{len}(c, b) + 2*\delta(c)} \\
   &amp; =  \frac{2*\delta(c)}{\mathrm{len}_c(a, b) + 2*\delta(c)}
\end{align*}
\]</span></p>
<p>And it can also be written in the <em>Lin_1998</em> form:</p>
<p><span class="math display">\[
\begin{align*}
 \mathrm{Sim}(a, b) &amp; = \frac{2*\delta(c)}{\delta(c) + \mathrm{len}(c, a) + \delta(c) + \mathrm{len}(c, b)} \\
   &amp; =  \frac{2*\delta(c)}{\delta_c(a) + \delta_c(b)}
\end{align*}
\]</span></p>
<p>where in the denominator are the depths of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via <span class="math inline">\(c\)</span>.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_WP_1994")
</pre>
<p>Paper link: <a href="https://doi.org/10.3115/981732.981751" class="external-link uri">https://doi.org/10.3115/981732.981751</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_slimani_2006">Sim_Slimani_2006<a class="anchor" aria-label="anchor" href="#sim_slimani_2006"></a>
</h4>
<p>It is a correction of the <em>Sim_WP_1994</em> method. The correction factor for term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> regarding to their LCA term <span class="math inline">\(c\)</span> is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \mathrm{CF}(a, b) * \mathrm{Sim}_\mathrm{WP}(a, b) \]</span></p>
<p>The correction factor <span class="math inline">\(\mathrm{CF}(a, b)\)</span> is based whether <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are in ancestor/offspring relationship or not.</p>
<p><span class="math display">\[ \mathrm{CF}(a, b) = \left\{ \begin{array}{ll}
\min\{ \delta(a), \delta(b)\} - \delta(c) = \min\{\mathrm{len}(c, a), \mathrm{len}(c, b)\} &amp; \textit{a} \text{ and } \textit{b} \text{ are not ancestor-offspring} \\
\frac{1}{1 + |\delta(a) - \delta(b)|} = \frac{1}{1 + \mathrm{len}(a,b)} &amp; \textit{a} \text{ and } \textit{b} \text{ are ancestor-offspring}
\end{array} \right. 
\]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Slimani_2006")
</pre>
<p>Paper link: <a href="https://zenodo.org/record/1075130" class="external-link uri">https://zenodo.org/record/1075130</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_shenoy_2012">Sim_Shenoy_2012<a class="anchor" aria-label="anchor" href="#sim_shenoy_2012"></a>
</h4>
<p>It is also a correction of the <em>Sim_WP_1994</em> method. The correction factor for term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is:</p>
<p><span class="math display">\[  \mathrm{CF}(a, b) = \left\{ \begin{array}{ll}
1 &amp; \textit{a} \text{ and } \textit{b} \text{ are not ancestor-offspring} \\
\exp(-\frac{D_\mathrm{sp}(a, b)}{\delta_\mathrm{max}})) &amp; \textit{a} \text{ and } \textit{b} \text{ are ancestor-offspring}
\end{array} \right. \]</span></p>
<p><span class="math inline">\(D_\mathrm{sp}\)</span> can be replaced with <span class="math inline">\(\mathrm{len}(a, b)\)</span> if the longest distance is used.</p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Shenoy_2012",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.48550/arXiv.1211.4709" class="external-link uri">https://doi.org/10.48550/arXiv.1211.4709</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_pekar_2002">Sim_Pekar_2002<a class="anchor" aria-label="anchor" href="#sim_pekar_2002"></a>
</h4>
<p>It is very similar to the <em>Sim_WP_1994</em> method:</p>
<p><span class="math display">\[
\begin{align*}
\mathrm{Sim}(a, b) &amp;= \frac{\delta(c)}{\mathrm{len}(c, a) + \mathrm{len}(c, b) + \delta(c)} \\
                   &amp;= \frac{\delta(c)}{\delta(c) + \mathrm{len}(c, a) + \delta(c) + \mathrm{len}(c, b) - \delta(c)} \\
                   &amp;= \frac{\delta(c)}{\delta_c(a) + \delta_c(b) - \delta(c)}
\end{align*}
\]</span></p>
<p>And the relationship to <span class="math inline">\(\mathrm{Sim}_\mathrm{WP}\)</span> is:</p>
<p><span class="math display">\[ \mathrm{Sim}_\mathrm{Pekar}(a, b) = \frac{\mathrm{Sim}_\mathrm{WP}(a, b)}{2 - \mathrm{Sim}_\mathrm{WP}(a, b)} \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Pekar_2002")
</pre>
<p>Paper link: <a href="https://aclanthology.org/C02-1090/" class="external-link uri">https://aclanthology.org/C02-1090/</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_stojanovic_2001">Sim_Stojanovic_2001<a class="anchor" aria-label="anchor" href="#sim_stojanovic_2001"></a>
</h4>
<p>It is purely based on the depth of term <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> and their LCA term <span class="math inline">\(c\)</span>.</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\delta(c)}{\delta(a) + \delta(b) - \delta(c)} \]</span></p>
<p>The similarity value might be negative because there is no restrction that the path from root to <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> must pass <span class="math inline">\(c\)</span>.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Stojanovic_2001")
</pre>
<p>Paper link: <a href="https://doi.org/10.1145/500737.500762" class="external-link uri">https://doi.org/10.1145/500737.500762</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_wang_edge_2012">Sim_Wang_edge_2012<a class="anchor" aria-label="anchor" href="#sim_wang_edge_2012"></a>
</h4>
<p>It is calculated as:</p>
<p><span class="math display">\[ 
\begin{align*}
\mathrm{Sim}(a, b) &amp; = \frac{\mathrm{len}(r, c)^2}{\mathrm{len}_c(r, a)*\mathrm{len}_c(r, b)} \\ 
   &amp; = \frac{\delta(c)^2}{\delta_c(a)*\delta_c(b)}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(r\)</span> is the root term.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Wang_edge_2012")
</pre>
<p>Paper link: <a href="https://doi.org/10.1186/1477-5956-10-s1-s18" class="external-link uri">https://doi.org/10.1186/1477-5956-10-s1-s18</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_zhong_2002">Sim_Zhong_2002<a class="anchor" aria-label="anchor" href="#sim_zhong_2002"></a>
</h4>
<p>For a term <span class="math inline">\(x\)</span>, it first calculates a “mile-stone” value based on the depth as</p>
<p><span class="math display">\[ m(x) = 2^{-\delta(x) - 1} \]</span></p>
<p>The the distance bewteen term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via LCA term <span class="math inline">\(c\)</span> is:</p>
<p><span class="math display">\[ 
\begin{align*}
D(a, b) &amp; = D(c, a) + D(c, b) \\
   &amp; = m(c) - m(a) + m(c) + m(b) \\
   &amp; = 2^{-\delta(c)} - 2^{-\delta(a) - 1} - 2^{-\delta(b) - 1}
\end{align*}
\]</span></p>
<p>We can change original <span class="math inline">\(\delta(a)\)</span> and <span class="math inline">\(\delta(b)\)</span> to <span class="math inline">\(\delta_c(a)\)</span> and <span class="math inline">\(\delta_c(b)\)</span> to require that the depth to reach <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> should go through <span class="math inline">\(c\)</span>. Then above equation becomes</p>
<p><span class="math display">\[ 
\begin{align*}
D(a, b) &amp; = 2^{-\delta(c)} - 2^{-\delta_c(a) - 1} - 2^{-\delta_c(b) - 1} \\
    &amp; = 2^{-\delta(c)} - 2^{-\delta(c)-\mathrm{len}(c,a)-1} - 2^{-\delta(c)-\mathrm{len}(c,b)-1} \\
    &amp; = 2^{-\delta(c)} \left( 1 - 2^{-\mathrm{len}(c,a)-1} - 2^{-\mathrm{len}(c,b)-1} \right)
\end{align*}
\]</span></p>
<p>Then when <span class="math inline">\(a = b\)</span> (the two terms are identical), <span class="math inline">\(D(a, b) = 0\)</span> and when <span class="math inline">\(c = r\)</span> (common ancestor only includes root) and <span class="math inline">\(\mathrm{len}(r, a) \to \infty\)</span>, <span class="math inline">\(\mathrm{len}(r, b) \to \infty\)</span> (root has infinite distance to the terms), <span class="math inline">\(D(a, b)\)</span> reaches maximal of 1. So the similarity</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - D(a, b)\]</span></p>
<p>ranges between 0 and 1.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Zhong_2002")
</pre>
<p>Paper link: <a href="https://doi.org/10.1007/3-540-45483-7_8" class="external-link uri">https://doi.org/10.1007/3-540-45483-7_8</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_almubaid_2006">Sim_AlMubaid_2006<a class="anchor" aria-label="anchor" href="#sim_almubaid_2006"></a>
</h4>
<p>It also takes accout of the distance between term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, as well as the depth of the LCA term <span class="math inline">\(c\)</span> in the DAG. The distance is calculated as:</p>
<p><span class="math display">\[ D(a, b) = \log(1 + D_\mathrm{sp}(a, b)*(\sigma_\mathrm{max} - \sigma(c))) \]</span></p>
<p>To scale <span class="math inline">\(D(a, b)\)</span> into the range of <code>[0, 1]</code>, we can calculate the smallest value as zero when <span class="math inline">\(a = b\)</span>. <span class="math inline">\(D(a, b)\)</span> reaches maximal when <span class="math inline">\(D_\mathrm{sp}(a, b)\)</span> reach possible maximal which is <span class="math inline">\(2*\delta_\mathrm{max}\)</span>. Then we can define the maximal of <span class="math inline">\(D(a, b)\)</span> as</p>
<p><span class="math display">\[ D_\mathrm{max} = \log(1 + 2*\delta_\mathrm{max} * \delta_\mathrm{max}) \]</span></p>
<p>And the similarity is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - D(a, b)/D_\mathrm{max} \]</span></p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_AlMubaid_2006",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1109/IEMBS.2006.259235" class="external-link uri">https://doi.org/10.1109/IEMBS.2006.259235</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_li_2003">Sim_Li_2003<a class="anchor" aria-label="anchor" href="#sim_li_2003"></a>
</h4>
<p>It is similar to the <em>Sim_AlMubaid_2006</em> method, but uses a non-linear form:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \exp(-0.2*D_\mathrm{sp}(a, b)) * \tanh(0.6*\delta(c)) \]</span></p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Li_2003",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1109/TKDE.2003.1209005" class="external-link uri">https://doi.org/10.1109/TKDE.2003.1209005</a>.</p>
</div>
<div class="section level3">
<h3 id="hybrid-methods">Hybrid methods<a class="anchor" aria-label="anchor" href="#hybrid-methods"></a>
</h3>
<p>Hybrid methods use both DAG structure information and IC.</p>
<div class="section level4">
<h4 id="sim_rss_2013">Sim_RSS_2013<a class="anchor" aria-label="anchor" href="#sim_rss_2013"></a>
</h4>
<p>The similarity is adjusted by the positions of term <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> and the LCA term <span class="math inline">\(c\)</span> in the DAG. The similarity is defined as:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{\delta_\mathrm{max}}{\delta_\mathrm{max} + D_\mathrm{sp}(a, b)} * \frac{\alpha}{\alpha + \beta} \]</span></p>
<p>where <span class="math inline">\(D_\mathrm{sp}(a, b)\)</span> can also be the longest distance via LCA. <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> in the second term are defined as:</p>
<p><span class="math display">\[
\begin{align*}
\alpha &amp; = \delta(c) \\
\beta &amp; = \min\{ \eta(a), \eta(b) \}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is the depth of LCA, <span class="math inline">\(\beta\)</span> corresponds to the distance to leaves, which is the smaller height of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in the DAG.</p>
<p>There is a parameter distance which takes value of <code>"longest_distances_via_LCA"</code> (the default) or <code>"shortest_distances_via_NCA"</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_RSS_2013",
    control = list(distance = "shortest_distances_via_NCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1371/journal.pone.0066745" class="external-link uri">https://doi.org/10.1371/journal.pone.0066745</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_hrss_2013">Sim_HRSS_2013<a class="anchor" aria-label="anchor" href="#sim_hrss_2013"></a>
</h4>
<p>It is similar to the <em>Sim_RSS_2013</em> method, but it uses information content instead of the distance to adjust the similarity.</p>
<p>It first defines the semantic distance between term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as the sum of the distance to their MICA term <span class="math inline">\(c\)</span>:</p>
<p><span class="math display">\[ D(a, b) = D(c, a) + D(c, b) \]</span></p>
<p>And the distance between an ancestor to a term is:</p>
<p><span class="math display">\[ 
\begin{align*}
D(c, a) &amp; = \mathrm{IC}(a) - \mathrm{IC}(c) \\
D(a, b) &amp; = D(c, a) + D(c, b) = \mathrm{IC}(a) + \mathrm{IC}(b) - 2*\mathrm{IC}(c)
\end{align*}
\]</span></p>
<p>Similarly, the similarity is also corrected by the position of MICA term and <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> in the DAG:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \frac{1}{1 + D(a, b)} * \frac{\alpha}{\alpha + \beta} \]</span></p>
<p>where</p>
<p><span class="math display">\[ \alpha = \mathrm{IC}(c) \]</span></p>
<p>And beta is the average of the maximal semantic distance of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to leaves.</p>
<p><span class="math display">\[ \beta = \frac{D(a, l_a) + D(b, l_b)}{2} = \frac{\mathrm{IC}(l_a) - \mathrm{IC}(a) + \mathrm{IC}(l_b) - \mathrm{IC}(b)}{2} \]</span></p>
<p>where <span class="math inline">\(l_a\)</span> or <span class="math inline">\(l_b\)</span> is the leaf with the highest IC that <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> can reach (i.e. the most informative leaf)</p>
<p><span class="math display">\[ \mathrm{IC}(l_a) = \max_{z \in \mathcal{L}(a)} \mathrm{IC}(z) \]</span></p>
<pre class="r">
term_sim(dag, terms, method = "Sim_HRSS_2013")
</pre>
<p>Paper link: <a href="https://doi.org/10.1371/journal.pone.0066745" class="external-link uri">https://doi.org/10.1371/journal.pone.0066745</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_shen_2010">Sim_Shen_2010<a class="anchor" aria-label="anchor" href="#sim_shen_2010"></a>
</h4>
<p>It is based on the information content of terms on the path connecting term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via their MICA term <span class="math inline">\(c\)</span>.</p>
<p>Denote a list of terms <code>a, ..., c, ..., b</code> which are composed by the shortest path from <span class="math inline">\(c\)</span> to <span class="math inline">\(a\)</span> and from <span class="math inline">\(c\)</span> to <span class="math inline">\(b\)</span>, the distance between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is the sum of <span class="math inline">\(1/\mathrm{IC}\)</span> of the terms on the path. Denote <span class="math inline">\(L_c(a, b)\)</span> as the set of terms on the shortest path connecting <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via the MICA term <span class="math inline">\(c\)</span>, the similarity is:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{\arctan \left( \sum\limits_{x \in L_c(a, b)} \frac{1}{\mathrm{IC}(x)} \right)}{\pi/2} \]</span></p>
<p>The path <span class="math inline">\(L_c(a, b)\)</span> can also be defined as the longest path via MICA. The <code>distance</code> parameter controls which type of paths to use.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Shen_2010",
    control = list(distance = "longest_distances_via_LCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1109/BIBM.2010.5706623" class="external-link uri">https://doi.org/10.1109/BIBM.2010.5706623</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_ssdd_2013">Sim_SSDD_2013<a class="anchor" aria-label="anchor" href="#sim_ssdd_2013"></a>
</h4>
<p>It is similar to the <em>Sim_Shen_2010</em> method which also sums information along the path passing through the LCA term. Instead of summing the information contents, the <em>Sim_SSDD_2013</em> method sums up a so-called “T-value” which relies on the DAG structure.</p>
<p>Denote <span class="math inline">\(L_c(a, b)\)</span> as the set of terms on the shortest path connecting <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via the LCA term <span class="math inline">\(c\)</span>, the similarity is calculated as:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = 1 - \frac{\arctan \left( \sum\limits_{x \in L_c(a, b)} T(x) \right) }{\pi/2} \]</span></p>
<p>The T-value <span class="math inline">\(T(x)\)</span> depends on the DAG structure which considers both parents and children of <span class="math inline">\(x\)</span>. The definition of <span class="math inline">\(T(x)\)</span> is:</p>
<p><span class="math display">\[
T(x) = \left\{ \begin{array}{ll}
1 &amp; \text{if }\textit{x}\text{ is a root} \\
\frac{1}{|\mathcal{P}_x|} \sum\limits_{t \in \mathcal{P}_x}(w * T(t)) &amp; \text{otherwise}
\end{array} \right.
\]</span></p>
<p>which means T-value of a term is an average of the weighted T-values of its parents. The weight <span class="math inline">\(w\)</span> measures the fraction of information a parent <span class="math inline">\(t\)</span> transmitting to downstream of the DAG via <span class="math inline">\(x\)</span>, defined as:</p>
<p><span class="math display">\[ w = \frac{|D_x^+|}{|D_t^+|} \]</span></p>
<p><span class="math inline">\(w \leq 1\)</span> as all offsprings of <span class="math inline">\(x\)</span> are also offspring of its parent <span class="math inline">\(t\)</span>.</p>
<p>The path <span class="math inline">\(L_c(a, b)\)</span> can also be defined as the longest path via MICA. The <code>distance</code> parameter controls which type of paths to use.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_SSDD_2013",
    control = list(distance = "longest_distances_via_LCA"))
</pre>
<p>Paper link: <a href="https://doi.org/10.1016/j.ygeno.2013.04.010" class="external-link uri">https://doi.org/10.1016/j.ygeno.2013.04.010</a>.</p>
</div>
<div class="section level4">
<h4 id="sim_jiang_1997">Sim_Jiang_1997<a class="anchor" aria-label="anchor" href="#sim_jiang_1997"></a>
</h4>
<p>First semantic distance between term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> via MICA term <span class="math inline">\(c\)</span> is defined as:</p>
<p><span class="math display">\[ D(a, b) = \mathrm{IC}(a) + \mathrm{IC}(b) - 2*\mathrm{IC}(c) \]</span></p>
<p>Then there are several normalization methods to change the distance to similarity and to scale it into the range of <code>[0, 1]</code>.</p>
<ul>
<li>
<code>"max"</code>: <span class="math inline">\(1 - \frac{D(a, b)}{2*\mathrm{IC}_\mathrm{max}}\)</span>
</li>
<li>
<code>"Couto"</code>: <span class="math inline">\(\min\{ 1, \frac{D(a, b)}{\mathrm{IC}_\mathrm{max}} \}\)</span>
</li>
<li>
<code>"Lin"</code>: <span class="math inline">\(1 - \frac{D(a, b)}{\mathrm{IC}(a) + \mathrm{IC}(b)}\)</span> which is the same as the <em>Sim_Lin_1998</em> method</li>
<li>
<code>"Garla"</code>: <span class="math inline">\(1 - \frac{\log(D(a, b) + 1)}{\log(2*\mathrm{IC}_\mathrm{max} + 1)}\)</span>
</li>
<li>
<code>"log-Lin"</code>: <span class="math inline">\(1 - \frac{\log(D(a, b) + 1)}{\log(\mathrm{IC}(a) + \mathrm{IC}(b) + 1)}\)</span>
</li>
<li>
<code>"Rada"</code>: <span class="math inline">\(\frac{1}{1 + D(a, b)}\)</span>
</li>
</ul>
<p>The normalization methods can be set via the parameter <code>norm_method</code>:</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "max"))
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "Couto"))
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "Lin"))
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "Garla"))
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "log-Lin"))
term_sim(dag, terms, method = "Sim_Jiang_1997", control = list(norm_method = "Rada"))
</pre>
<p>Paper link: <a href="https://aclanthology.org/O97-1002/" class="external-link uri">https://aclanthology.org/O97-1002/</a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="annotation-count-based-methods">Annotation-count based methods<a class="anchor" aria-label="anchor" href="#annotation-count-based-methods"></a>
</h3>
<p>Denote <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as the sets of items annotated to term <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, and <span class="math inline">\(U\)</span> as the universe set of all items annotated to the DAG.</p>
<div class="section level4">
<h4 id="sim_kappa">Sim_Kappa<a class="anchor" aria-label="anchor" href="#sim_kappa"></a>
</h4>
<p>The definition of kappa coeffient is a little bit complex. First let’s format the two sets into a contigency table:</p>
<style>
table.contigency-table {
    border-collapse: collapse;
}
table.contigency-table td {
    border: 1px solid black;
    padding: 2px 5px;
}
.symbol {
    font-family: Times;
    font-style: italic;
}
</style>
<center>
<table class="table contigency-table">
<tr>
<td rowspan="2" colspan="2">
</td>
<td colspan="2">
In set <b><i>B</i></b>
</td>
</tr>
<tr>
<td>
Yes
</td>
<td>
No
</td>
</tr>
<tr>
<td rowspan="2">
In set <b><i>A</i></b>
</td>
<td>
Yes
</td>
<td class="symbol">
a
</td>
<td class="symbol">
b
</td>
</tr>
<tr>
<td>
No
</td>
<td class="symbol">
c
</td>
<td class="symbol">
d
</td>
</tr>
</table>
</center>
<p>where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(d\)</span> are the numbers of items that fall in each category.</p>
<p>Let’s calculate <span class="math inline">\(p_\mathrm{obs}\)</span> (probability of observed agreement, both yes or both no) and <span class="math inline">\(p_\mathrm{exp}\)</span> (probability of expected agreement) as:</p>
<p><span class="math display">\[
\begin{align*}
p_\mathrm{obs} &amp; = \frac{a+d}{a+b+c+d} \\
p_\mathrm{Yes} &amp; = \frac{a+b}{a+b+c+d} * \frac{a+c}{a+b+c+d} \\
p_\mathrm{No} &amp; = \frac{c+d}{a+b+c+d} * \frac{b+d}{a+b+c+d} \\
p_\mathrm{exp} &amp; = p_\mathrm{Yes} + p_\mathrm{No}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(p_\mathrm{obs}\)</span> is the probability of an item in both sets or neither in both sets, <span class="math inline">\(p_\mathrm{Yes}\)</span> is the probability of an item in both sets by random (by assuming the events of an item in set <span class="math inline">\(A\)</span> and set <span class="math inline">\(B\)</span> are independent), <span class="math inline">\(p_\mathrm{No}\)</span> is the probability of an item not in the two sets by random, and <span class="math inline">\(p_\mathrm{exp}\)</span> is the probability of an item either both in the two sets or not in the two sets by random.</p>
<p>The kappa coeffcient is calculated as:</p>
<p><span class="math display">\[ \mathrm{Sim}(a, b) = \mathrm{Kappa}(a, b) = \frac{p_\mathrm{obs} - p_\mathrm{exp}}{1 - p_\mathrm{exp}}\]</span></p>
<p>Note the Kappa coeffcient is possible to be negative.</p>
<p>The universe set can be set via the parameter <code>anno_universe</code>. By default it is the total items annotated to the whole DAG.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_kappa",
    control = list(anno_universe = ...))
</pre>
</div>
<div class="section level4">
<h4 id="sim_jaccard-sim_dice-and-sim_overlap">Sim_Jaccard, Sim_Dice and Sim_Overlap<a class="anchor" aria-label="anchor" href="#sim_jaccard-sim_dice-and-sim_overlap"></a>
</h4>
<p>Definitions of the Jaccard, Dice and overlap coeffcients are similar. The Jaccard coeffcient is:</p>
<p><span class="math display">\[ \mathrm{Jaccard}(a, b) = \frac{|A \cap B|}{|A \cup B|} \]</span></p>
<p>The Dice coeffcient is:</p>
<p><span class="math display">\[ \mathrm{Dice}(a, b) = \frac{2*|A \cap B|}{|A| + |B|} \]</span></p>
<p>The overlap coeffcient is:</p>
<p><span class="math display">\[ \mathrm{Overlap}(a, b) = \frac{|A \cap B|}{\min\{|A|, |B|\}} \]</span></p>
<p>Dice and Jaccard coeffcients have a relation of:</p>
<p><span class="math display">\[ \mathrm{Jaccard} = \frac{\mathrm{Dice}}{2 - \mathrm{Dice}} \]</span></p>
<p>The universe set can be set via the parameter <code>anno_universe</code>. By default it is the total items annotated to the whole DAG.</p>
<pre class="r">
term_sim(dag, terms, method = "Sim_Jaccard",
    control = list(anno_universe = ...))
term_sim(dag, terms, method = "Sim_Dice",
    control = list(anno_universe = ...))
term_sim(dag, terms, method = "Sim_Overlap",
    control = list(anno_universe = ...))
</pre>
</div>
</div>
<div class="section level3">
<h3 id="session-info">Session Info<a class="anchor" aria-label="anchor" href="#session-info"></a>
</h3>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## R version 4.3.1 (2023-06-16)</span></span>
<span><span class="co">## Platform: x86_64-apple-darwin20 (64-bit)</span></span>
<span><span class="co">## Running under: macOS Ventura 13.2.1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Matrix products: default</span></span>
<span><span class="co">## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib </span></span>
<span><span class="co">## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## locale:</span></span>
<span><span class="co">## [1] C/UTF-8/C/C/C/C</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## time zone: Europe/Berlin</span></span>
<span><span class="co">## tzcode source: internal</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## attached base packages:</span></span>
<span><span class="co">## [1] stats     graphics  grDevices utils     datasets  methods   base     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## other attached packages:</span></span>
<span><span class="co">## [1] simona_1.1.6 knitr_1.44  </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## loaded via a namespace (and not attached):</span></span>
<span><span class="co">##  [1] sass_0.4.7            xml2_1.3.5            shape_1.4.6          </span></span>
<span><span class="co">##  [4] stringi_1.7.12        digest_0.6.33         magrittr_2.0.3       </span></span>
<span><span class="co">##  [7] evaluate_0.22         grid_4.3.1            RColorBrewer_1.1-3   </span></span>
<span><span class="co">## [10] iterators_1.0.14      circlize_0.4.15       fastmap_1.1.1        </span></span>
<span><span class="co">## [13] foreach_1.5.2         doParallel_1.0.17     rprojroot_2.0.3      </span></span>
<span><span class="co">## [16] jsonlite_1.8.7        GlobalOptions_0.1.2   promises_1.2.1       </span></span>
<span><span class="co">## [19] ComplexHeatmap_2.16.0 purrr_1.0.2           codetools_0.2-19     </span></span>
<span><span class="co">## [22] textshaping_0.3.7     jquerylib_0.1.4       shiny_1.6.0          </span></span>
<span><span class="co">## [25] cli_3.6.1             rlang_1.1.1           crayon_1.5.2         </span></span>
<span><span class="co">## [28] scatterplot3d_0.3-44  ellipsis_0.3.2        cachem_1.0.8         </span></span>
<span><span class="co">## [31] yaml_2.3.7            tools_4.3.1           parallel_4.3.1       </span></span>
<span><span class="co">## [34] memoise_2.0.1         colorspace_2.1-0      httpuv_1.6.11        </span></span>
<span><span class="co">## [37] GetoptLong_1.0.5      BiocGenerics_0.46.0   mime_0.12            </span></span>
<span><span class="co">## [40] vctrs_0.6.4           R6_2.5.1              png_0.1-8            </span></span>
<span><span class="co">## [43] matrixStats_1.0.0     stats4_4.3.1          lifecycle_1.0.3      </span></span>
<span><span class="co">## [46] stringr_1.5.0         S4Vectors_0.38.2      fs_1.6.3             </span></span>
<span><span class="co">## [49] IRanges_2.34.1        clue_0.3-65           cluster_2.1.4        </span></span>
<span><span class="co">## [52] ragg_1.2.6            pkgconfig_2.0.3       desc_1.4.2           </span></span>
<span><span class="co">## [55] later_1.3.1           pkgdown_2.0.7         bslib_0.5.1          </span></span>
<span><span class="co">## [58] Rcpp_1.0.11           glue_1.6.2            systemfonts_1.0.5    </span></span>
<span><span class="co">## [61] xfun_0.40             xtable_1.8-4          rjson_0.2.21         </span></span>
<span><span class="co">## [64] igraph_1.5.1          htmltools_0.5.6.1     rmarkdown_2.25       </span></span>
<span><span class="co">## [67] Polychrome_1.5.1      compiler_4.3.1</span></span></code></pre>
<script src="jquery.min.js"></script><script src="jquery.sticky.js"></script><script>
$(document).ready(function(){
    $("#TOC").sticky({
        topSpacing: 0,
        zIndex:1000    
    })
    $("#TOC").on("sticky-start", function() {

        $("<p style='font-size:1.2em; padding-left:4px;'><a id='TOC-click'>Table of Content</a></p>").insertBefore($("#TOC ul:first-child"));
        $("#TOC-click").hover(function() {
            $(this).css("color", "#0033dd").css("cursor", "pointer");
            $("#TOC").children().first().next().show();
            $("#TOC").hover(function() {
                $(this).children().first().next().show();
            }, function() {
                $(this).children().first().next().hide();
                $("body").off("hover", "#TOC");
            })
        }, function() {
            $(this).css("color", "#0033dd");
        })
        $("#TOC").children().first().next().hide();

    })
    $("#TOC").on("sticky-end", function() {
        $("#TOC").children().first().remove();
        $("#TOC").children().first().show();
    })
});
</script>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Zuguang Gu.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
