<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Semantic similarity — term_sim • simona</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Semantic similarity — term_sim"><meta property="og:description" content="Semantic similarity"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">simona</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.1.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/v01_dag.html">ontology_DAG: a class for ontology data</a>
    </li>
    <li>
      <a href="../articles/v02_GO.html">Gene Ontology</a>
    </li>
    <li>
      <a href="../articles/v03_import.html">Import ontology files</a>
    </li>
    <li>
      <a href="../articles/v04_information_content.html">Information content</a>
    </li>
    <li>
      <a href="../articles/v05_term_similarity.html">Term similarity</a>
    </li>
    <li>
      <a href="../articles/v06_group_similarity.html">Similarity between two groups of terms</a>
    </li>
    <li>
      <a href="../articles/v07_dag_visualization.html">Visualize DAGs</a>
    </li>
    <li>
      <a href="../articles/v08_random.html">Random DAGs</a>
    </li>
    <li>
      <a href="../articles/v09_shiny.html">Shiny app</a>
    </li>
    <li>
      <a href="../articles/v10_enrichment.html">Functional enrichment</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/jokergoo/simona/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Semantic similarity</h1>
    <small class="dont-index">Source: <a href="https://github.com/jokergoo/simona/blob/HEAD/R/methods.R" class="external-link"><code>R/methods.R</code></a></small>
    <div class="hidden name"><code>term_sim.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Semantic similarity</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">term_sim</span><span class="op">(</span><span class="va">dag</span>, <span class="va">terms</span>, <span class="va">method</span>, control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, verbose <span class="op">=</span> <span class="va">simona_opt</span><span class="op">$</span><span class="va">verbose</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>dag</dt>
<dd><p>An <code>ontology_DAG</code> object.</p></dd>


<dt>terms</dt>
<dd><p>A vector of term names.</p></dd>


<dt>method</dt>
<dd><p>A term similarity method. All available methods are in <code><a href="all_methods.html">all_term_sim_methods()</a></code>.</p></dd>


<dt>control</dt>
<dd><p>A list of parameters passing to individual methods. See the subsections.</p></dd>


<dt>verbose</dt>
<dd><p>Whether to print messages.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p>A numeric symmetric matrix.</p>
    </div>
    <div id="methods">
    <h2>Methods</h2>
    

<div class="section">
<h3 id="sim-lin-">Sim_Lin_1998<a class="anchor" aria-label="anchor" href="#sim-lin-"></a></h3>


<p>The similarity between two terms <code>a</code> and <code>b</code> is calculated as the IC of their MICA term <code>c</code> normalized by the average of the IC of the two terms:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC</span>(c)<span class="sc">/</span>((<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b))<span class="sc">/</span><span class="dv">2</span>) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC</span>(c)<span class="sc">/</span>(<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>Although any IC method can be used here, in more applications, it is normally used together with the <em>IC_annotation</em> method.</p>
<p>Paper link: <a href="https://doi.org/10.5555/645527.657297" class="external-link">doi:10.5555/645527.657297</a>
.</p>
</div>


<div class="section">
<h3 id="sim-resnik-">Sim_Resnik_1999<a class="anchor" aria-label="anchor" href="#sim-resnik-"></a></h3>


<p>The IC method is fixed to <code>IC_annotation</code>.</p>
<p>The original Resnik similarity is the IC of the MICA term. There are three ways to normalize the Resnik similarity into the scale of <code>[0, 1]</code>:</p><ol><li><p><em>Nunif</em></p></li>
</ol><p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC</span>(c)<span class="sc">/</span><span class="fu">log</span>(N)</span></code></pre><p></p></div>
<p>where <code>N</code> is the total number of items annotated to the whole DAG, i.e. number of items annotated to the root. Then the IC
of a term with only one item annotated is <code>-log(1/N)</code> = log(N)` which is the maximal IC value in the DAG.</p><ol><li><p><em>Nmax</em></p></li>
</ol><p><code>IC_max</code> is the maximal IC of all terms. If there is a term with only one item annotated, <code>Nmax</code> is identical to the `Nunif* method.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC</span>(c)<span class="sc">/</span>IC_max</span></code></pre><p></p></div><ol><li><p><em>Nunivers</em></p></li>
</ol><p>The IC is normalized by the maximal IC of term <code>a</code> and <code>b</code>.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC</span>(c)<span class="sc">/</span><span class="fu">max</span>(<span class="fu">IC</span>(a), <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1613/jair.514" class="external-link">doi:10.1613/jair.514</a>
, <a href="https://doi.org/10.1186/1471-2105-9-S5-S4" class="external-link">doi:10.1186/1471-2105-9-S5-S4</a>
, <a href="https://doi.org/10.1186/1471-2105-11-562" class="external-link">doi:10.1186/1471-2105-11-562</a>
, <a href="https://doi.org/10.1155/2013/292063" class="external-link">doi:10.1155/2013/292063</a>
.</p>
<p>The normalization method can be set with the <code>norm_method</code> parameter:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">control =</span> <span class="fu">list</span>(<span class="at">norm_method =</span> <span class="st">"Nmax"</span>))</span></code></pre><p></p></div>
<p>Possible values for the <code>norm_method</code> parameter are "Nunif", "Nmax", "Nunivers" and "none".</p>
</div>


<div class="section">
<h3 id="sim-faith-">Sim_FaITH_2010<a class="anchor" aria-label="anchor" href="#sim-faith-"></a></h3>


<p>It is calculated as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC</span>(c)<span class="sc">/</span>(<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b) <span class="sc">-</span> <span class="fu">IC</span>(c))</span></code></pre><p></p></div>
<p>The relation between <em>FaITH_2010</em> similarity and <em>Lin_1998</em> similarity is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim_FaITH <span class="ot">=</span> sim_Lin<span class="sc">/</span>(<span class="dv">2</span> <span class="sc">-</span> sim_Lin)</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1007/978-3-642-17746-0_39" class="external-link">doi:10.1007/978-3-642-17746-0_39</a>
.</p>
</div>


<div class="section">
<h3 id="sim-relevance-">Sim_Relevance_2006<a class="anchor" aria-label="anchor" href="#sim-relevance-"></a></h3>


<p>The IC method is fixed to <code>IC_annotation</code>.</p>
<p>If thinking <em>Lin_1998</em> is a measure of how close term <code>a</code> and <code>b</code> to their MICA term <code>c</code>, the relevance method corrects it by multiplying
a factor which considers the specificity of how <code>c</code> brings the information. The factor is calculated as <code>1-p(c)</code> where <code>p(c)</code> is the annotation-based
probability <code>p(c) = k/N</code> where <code>k</code> is the number of items annotated to <code>c</code> and <code>N</code> is the total number of items annotated to the DAG. Then
the Relevance semantic similarity is calculated as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">p</span>(c)) <span class="sc">*</span> IC_Lin </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">p</span>(c)) <span class="sc">*</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC</span>(c)<span class="sc">/</span>(<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1186/1471-2105-7-302" class="external-link">doi:10.1186/1471-2105-7-302</a>
.</p>
</div>


<div class="section">
<h3 id="sim-simic-">Sim_SimIC_2010<a class="anchor" aria-label="anchor" href="#sim-simic-"></a></h3>


<p>The IC method is fixed to <code>IC_annotation</code>.</p>
<p>The SimIC method is an improved correction method of the Relevance method because the latter works bad when <code>p(c)</code> is very small. The SimIC
correction factor for MICA term <code>c</code> is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="sc">-</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">IC</span>(c))</span></code></pre><p></p></div>
<p>Then the similarity is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">IC</span>(c))) <span class="sc">*</span> IC_Lin </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">IC</span>(c))) <span class="sc">*</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC</span>(c)<span class="sc">/</span>(<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.48550/arXiv.1001.0958" class="external-link">doi:10.48550/arXiv.1001.0958</a>
.</p>
</div>


<div class="section">
<h3 id="sim-xgrasm-">Sim_XGraSM_2013<a class="anchor" aria-label="anchor" href="#sim-xgrasm-"></a></h3>


<p>The IC method is fixed to <code>IC_annotation</code>.</p>
<p>Being different from the "Relevance" and "SimIC_2010" methods that only use the IC of the MICA term, the <em>XGraSM_2013</em> uses IC of all common ancestor terms of <code>a</code> and <code>b</code>.
First it calculates the mean IC of all common ancestor terms with positive IC values:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>IC_mean <span class="ot">=</span> <span class="fu">mean_t</span>(<span class="fu">IC</span>(t)) where t is an ancestor of both a and b, and <span class="fu">IC</span>(t) <span class="sc">&gt;</span> <span class="dv">0</span></span></code></pre><p></p></div>
<p>then similar to the <em>Lin_1998</em> method, normalize to the average IC of <code>a</code> and <code>b</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> IC_mean<span class="sc">*</span><span class="dv">2</span><span class="sc">/</span>(<span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1186/1471-2105-14-284" class="external-link">doi:10.1186/1471-2105-14-284</a>
.</p>
</div>


<div class="section">
<h3 id="sim-eisi-">Sim_EISI_2015<a class="anchor" aria-label="anchor" href="#sim-eisi-"></a></h3>


<p>The IC method is fixed to <code>IC_annotation</code>.</p>
<p>It also selects a subset of common ancestors of terms <code>a</code> and <code>b</code>. It only selects common ancestors which can reach <code>a</code> or <code>b</code> via one of its child terms
that does not belong to the common ancestors. In other words, from the common ancestor, there exist a path where
the information is uniquely transmitted to <code>a</code> or <code>b</code>, not passing the other.</p>
<p>Then the mean IC of the subset common ancestors is calculated and normalized by the <em>Lin_1998</em> method.</p>
<p>Paper link: <a href="https://doi.org/10.1016/j.gene.2014.12.062" class="external-link">doi:10.1016/j.gene.2014.12.062</a>
.</p>
</div>


<div class="section">
<h3 id="sim-aic-">Sim_AIC_2014<a class="anchor" aria-label="anchor" href="#sim-aic-"></a></h3>


<p>It uses the aggregate information content from ancestors. First define the semantic weight (<code>Sw</code>) of a term <code>t</code> in the DAG:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Sw <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="fu">IC</span>(t)))</span></code></pre><p></p></div>
<p>Then calculate the aggregation only in the common ancestors and the aggregationn
in the ancestors of the two terms <code>a</code> and <code>b</code> separatedly:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>SV_{common ancestors} <span class="ot">=</span> sum_{t <span class="cf">in</span> common ancestors}(<span class="fu">Sw</span>(t))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>SV_a <span class="ot">=</span> sum{a<span class="st">' in a'</span>s ancestors}(<span class="fu">Sw</span>(a<span class="st">'))</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">SV_b = sum{b'</span> <span class="cf">in</span> b<span class="st">'s ancestors}(Sw(b'</span>))</span></code></pre><p></p></div>
<p>The similarity is calculated as the ratio between the aggregation on the common ancestors and the average on <code>a</code>'s ancestors and <code>b</code>'s ancestors separatedly.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span>SV_{common_ancestors}<span class="sc">/</span>(SV_a <span class="sc">+</span> SV_b)</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1109/tcbb.2013.176" class="external-link">doi:10.1109/tcbb.2013.176</a>
.</p>
</div>


<div class="section">
<h3 id="sim-zhang-">Sim_Zhang_2006<a class="anchor" aria-label="anchor" href="#sim-zhang-"></a></h3>


<p>It uses the <em>IC_Zhang_2006</em> IC method and the <em>Lin_1998</em> method to calculate similarities:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC_zhang</span>(c)<span class="sc">/</span>(<span class="fu">IC_zhang</span>(a) <span class="sc">+</span> <span class="fu">IC_zhang</span>(b))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-universal">Sim_universal<a class="anchor" aria-label="anchor" href="#sim-universal"></a></h3>


<p>It uses the <em>IC_universal</em> IC method and the <em>Nunivers</em> method to calculate similarities:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">IC_universal</span>(c)<span class="sc">/</span><span class="fu">max</span>(<span class="fu">IC_universal</span>(a), <span class="fu">IC_universal</span>(b))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-wang-">Sim_Wang_2007<a class="anchor" aria-label="anchor" href="#sim-wang-"></a></h3>


<p>First, S-value of an ancestor term <code>c</code> on a term <code>a</code> (<code>S(c-&gt;a)</code>) is calculated (the definition of the S-value can be found in the help page of <code><a href="term_IC.html">term_IC()</a></code>).
Similar to the <em>Sim_AIC_2014</em>, aggregation only to common ancestors, to <code>a</code>'s ancestors and to <code>b</code>'s ancestors are calculated.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>SV_{common ancestors} <span class="ot">=</span> sum_{c <span class="cf">in</span> common ancestors}(<span class="fu">S</span>(c<span class="ot">-&gt;</span>a) <span class="sc">+</span> <span class="fu">S</span>(c<span class="ot">-&gt;</span>b))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>SV_a <span class="ot">=</span> sum{a<span class="st">' in a'</span>s ancestors}(<span class="fu">S</span>(a<span class="st">'-&gt;a))</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">SV_b = sum{b'</span> <span class="cf">in</span> b<span class="st">'s ancestors}(S(b'</span><span class="ot">-&gt;</span>b))</span></code></pre><p></p></div>
<p>Then the similarity is calculated as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> SV_{common_ancestors}<span class="sc">*</span><span class="dv">2</span><span class="sc">/</span>(SV_a <span class="sc">+</span> SV_b)</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1093/bioinformatics/btm087" class="external-link">doi:10.1093/bioinformatics/btm087</a>
.</p>
<p>The contribution of different semantic relations can be set with the <code>contribution_factor</code> parameter. The value should be a named numeric
vector where names should cover the relations defined in <code>relations</code> set in <code><a href="create_ontology_DAG.html">create_ontology_DAG()</a></code>. For example, if there are two relations
"relation_a" and "relation_b" set in the DAG, the value for <code>contribution_factor</code> can be set as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Wang_2007"</span>, </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">contribution_factor =</span> <span class="fu">c</span>(<span class="st">"relation_a"</span> <span class="ot">=</span> <span class="fl">0.8</span>, <span class="st">"relation_b"</span> <span class="ot">=</span> <span class="fl">0.6</span>)))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-gogo-">Sim_GOGO_2018<a class="anchor" aria-label="anchor" href="#sim-gogo-"></a></h3>


<p>It is very similar as <em>Sim_Wang_2007</em>, but with a corrected contribution factor when calculating the S-value.
From a parent term to a child term, <em>Sim_Wang_2007</em> directly uses a weight for the relation between the parent
and the child, e.g. 0.8 for "is_a" relation type and 0.6 for "part_of" relation type. In <em>Sim_GOGO_2018</em>, the weight
is also scaled by the total number of children of that parent:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>w <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span>(c <span class="sc">+</span> nc) <span class="sc">+</span> w_0</span></code></pre><p></p></div>
<p>where w_0 is the original contribution factor, <code>nc</code> is the number of child terms of the parent, <code>c</code> is calculated to ensure that
maximal value of <code>w</code> is no larger than 1, i.e. <code>c = max(w_0)/(1 - max(w_0))</code>, assuming minimal value of <code>nc</code> is 1. By default <em>Sim_GOGO_2018</em>
sets contribution factor of 0.4 for "is_a" and 0.3 for "part_of", then <code>w = 1/(2/3 + nc) + w_0</code>.</p>
<p>Paper link: <a href="https://doi.org/10.1038/s41598-018-33219-y" class="external-link">doi:10.1038/s41598-018-33219-y</a>
.</p>
<p>The contribution of different semantic relations can be set with the <code>contribution_factor</code> parameter. The value should be a named numeric
vector where names should cover the relations defined in <code>relations</code> set in <code><a href="create_ontology_DAG.html">create_ontology_DAG()</a></code>. For example, if there are two relations
"relation_a" and "relation_b" set in the DAG, the value for <code>contribution_factor</code> can be set as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_GOGO_2018"</span>, </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">contribution_factor =</span> <span class="fu">c</span>(<span class="st">"relation_a"</span> <span class="ot">=</span> <span class="fl">0.4</span>, <span class="st">"relation_b"</span> <span class="ot">=</span> <span class="fl">0.3</span>)))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-rada-">Sim_Rada_1989<a class="anchor" aria-label="anchor" href="#sim-rada-"></a></h3>


<p>It is based on the distance between term <code>a</code> and <code>b</code>. It is defined as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">d</span>(a, b))</span></code></pre><p></p></div>
<p>The distance can be the shortest distance between <code>a</code> and <code>b</code> or the longest distance via the LCA term.</p>
<p>Paper link: <a href="https://doi.org/10.1109/21.24528" class="external-link">doi:10.1109/21.24528</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Rada_1989"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-resnik-edge-">Sim_Resnik_edge_2005<a class="anchor" aria-label="anchor" href="#sim-resnik-edge-"></a></h3>


<p>It is also based on the distance between term <code>a</code> and <code>b</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">d</span>(a, b)<span class="sc">/</span><span class="dv">2</span><span class="sc">/</span>max_depth</span></code></pre><p></p></div>
<p>where <code>max_depth</code> is the maximal depth (maximal distance from root) in the DAG. Similarly, <code>d(a, b)</code> can be the shortest
distance or the longest distance via LCA.</p>
<p>Paper link: <a href="https://doi.org/10.1145/1097047.1097051" class="external-link">doi:10.1145/1097047.1097051</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Resnik_edge_2005"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-leocock-">Sim_Leocock_1998<a class="anchor" aria-label="anchor" href="#sim-leocock-"></a></h3>


<p>It is similar as the <em>Sim_Resnik_edge_2005</em> method, but it applies log-transformation on the distance and the depth:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">log</span>(<span class="fu">d</span>(a, b) <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">/</span><span class="fu">log</span>(<span class="dv">2</span><span class="sc">*</span>max_depth <span class="sc">+</span> <span class="dv">1</span>)</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1186/1471-2105-13-261" class="external-link">doi:10.1186/1471-2105-13-261</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Leocock_1998"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-wp-">Sim_WP_1994<a class="anchor" aria-label="anchor" href="#sim-wp-"></a></h3>


<p>It is based on the depth of the LCA term <code>c</code> and the longest distance between term <code>a</code> and <code>b</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">depth</span>(c)<span class="sc">/</span>(<span class="fu">len_c</span>(a, b) <span class="sc">+</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">depth</span>(c))</span></code></pre><p></p></div>
<p>where <code>len_c(a, b)</code> is the longest distance between <code>a</code> and <code>b</code> via LCA <code>c</code>. The denominator in the equation can also be written as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">len_c</span>(a, b) <span class="sc">+</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">depth</span>(c) <span class="ot">=</span> <span class="fu">depth</span>(c) <span class="sc">+</span> <span class="fu">len</span>(c, a) <span class="sc">+</span> <span class="fu">depth</span>(c) <span class="sc">+</span> <span class="fu">len</span>(c, b)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                         <span class="ot">=</span> <span class="fu">depth_c</span>(a) <span class="sc">+</span> <span class="fu">depth_c</span>(b)</span></code></pre><p></p></div>
<p>where <code>depth_c(a)</code> is the longest distance from root to <code>a</code> passing through <code>c</code>.</p>
<p>Paper link: <a href="https://doi.org/10.3115/981732.981751" class="external-link">doi:10.3115/981732.981751</a>
.</p>
</div>


<div class="section">
<h3 id="sim-slimani-">Sim_Slimani_2006<a class="anchor" aria-label="anchor" href="#sim-slimani-"></a></h3>


<p>It is a correction of the <em>Sim_WP_1994</em> method. The correction factor for term <code>a</code> and <code>b</code> regarding to their LCA <code>t</code> is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">CF</span>(a, b) <span class="ot">=</span> (<span class="dv">1</span><span class="sc">-</span>lambda)<span class="sc">*</span>(<span class="fu">min</span>(<span class="fu">depth</span>(a), <span class="fu">depth</span>(b)) <span class="sc">-</span> <span class="fu">depth</span>(c)) <span class="sc">+</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>           lambda<span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">abs</span>(<span class="fu">depth</span>(a) <span class="sc">-</span> <span class="fu">depth</span>(b)))</span></code></pre><p></p></div>
<p><code>lambda</code> takes value of 1 if <code>a</code> and <code>b</code> are in ancestor-offspring relation, or else it takes 0.</p>
<p>Paper link: <a href="https://zenodo.org/record/1075130" class="external-link">https://zenodo.org/record/1075130</a>.</p>
</div>


<div class="section">
<h3 id="sim-shenoy-">Sim_Shenoy_2012<a class="anchor" aria-label="anchor" href="#sim-shenoy-"></a></h3>


<p>It is a correction of the <em>Sim_WP_1994</em> method. The correction factor for term <code>a</code> and <code>b</code> is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">CF</span>(a, b) <span class="ot">=</span> <span class="fu">exp</span>(<span class="sc">-</span>lambda<span class="sc">*</span><span class="fu">d</span>(a, b)<span class="sc">/</span>max_depth)</span></code></pre><p></p></div>
<p><code>lambda</code> takes value of 1 if <code>a</code> and <code>b</code> are in ancestor-offspring relation, or else it takes 0. `d(a, b)</p>
<p>Paper link: <a href="https://doi.org/10.48550/arXiv.1211.4709" class="external-link">doi:10.48550/arXiv.1211.4709</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Leocock_1998"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-pekar-">Sim_Pekar_2002<a class="anchor" aria-label="anchor" href="#sim-pekar-"></a></h3>


<p>It is very similar to the <em>Sim_WP_1994</em> method:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">depth</span>(c)<span class="sc">/</span>(<span class="fu">len_c</span>(a, b) <span class="sc">+</span> <span class="fu">depth</span>(c))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">d</span>(root, c)<span class="sc">/</span>(<span class="fu">d</span>(c, a) <span class="sc">+</span> <span class="fu">d</span>(c, b) <span class="sc">+</span> <span class="fu">d</span>(root, c))</span></code></pre><p></p></div>
<p>where <code>d(a, b)</code> is the longest distance between <code>a</code> and <code>b</code>.</p>
<p>Paper link: <a href="https://aclanthology.org/C02-1090/" class="external-link">https://aclanthology.org/C02-1090/</a>.</p>
</div>


<div class="section">
<h3 id="sim-stojanovic-">Sim_Stojanovic_2001<a class="anchor" aria-label="anchor" href="#sim-stojanovic-"></a></h3>


<p>It is purely based on the depth of term <code>a</code>, <code>b</code> and their LCA <code>c</code>.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">depth</span>(c)<span class="sc">/</span>(<span class="fu">depth</span>(a) <span class="sc">+</span> <span class="fu">depth</span>(b) <span class="sc">-</span> <span class="fu">depth</span>(c))</span></code></pre><p></p></div>
<p>The similarity value might be negative because there is no restrction that the path from root to <code>a</code> or <code>b</code> must pass <code>c</code>.</p>
<p>Paper link: <a href="https://doi.org/10.1145/500737.500762" class="external-link">doi:10.1145/500737.500762</a>
.</p>
</div>


<div class="section">
<h3 id="sim-wang-edge-">Sim_Wang_edge_2012<a class="anchor" aria-label="anchor" href="#sim-wang-edge-"></a></h3>


<p>It is calculated as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">depth</span>(c)<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span><span class="fu">depth_c</span>(a)<span class="sc">/</span><span class="fu">depth_c</span>(b)</span></code></pre><p></p></div>
<p>where <code>depth_c(a)</code> is the longest distance between root to <code>a</code> passing through <code>c</code>.</p>
<p>Paper link: <a href="https://doi.org/10.1186/1477-5956-10-s1-s18" class="external-link">doi:10.1186/1477-5956-10-s1-s18</a>
.</p>
</div>


<div class="section">
<h3 id="sim-zhong-">Sim_Zhong_2002<a class="anchor" aria-label="anchor" href="#sim-zhong-"></a></h3>


<p>For a term <code>x</code>, it first calculates a "mile-stone" value as</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">m</span>(x) <span class="ot">=</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(x)</span></code></pre><p></p></div>
<p>The the distance bewteen term <code>a</code> and <code>b</code> via LCA term <code>c</code> is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(c, a) <span class="sc">+</span> <span class="fu">D</span>(c, b) <span class="ot">=</span> <span class="fu">m</span>(c) <span class="sc">-</span> <span class="fu">m</span>(a) <span class="sc">+</span> <span class="fu">m</span>(c) <span class="sc">-</span> <span class="fu">m</span>(b)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                  <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">m</span>(c) <span class="sc">-</span> <span class="fu">m</span>(a) <span class="sc">-</span> <span class="fu">m</span>(b)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                  <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(c) <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(a) <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(b)</span></code></pre><p></p></div>
<p>We change the original <code>depth(a)</code> to let it go through LCA term <code>c</code> when calculating the depth:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(c) <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(a) <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(b) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(c)<span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span>(<span class="fu">depth</span>(c) <span class="sc">+</span> <span class="fu">len</span>(c, a)) <span class="sc">-</span> <span class="fl">0.5</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span>(<span class="fu">depth</span>(c) <span class="sc">+</span> <span class="fu">len</span>(c, b))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span><span class="fu">depth</span>(c) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span>(<span class="fu">len</span>(c, a) <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">-</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span><span class="sc">^</span>(<span class="fu">len</span>(c, b) <span class="sc">+</span> <span class="dv">1</span>))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dv">2</span><span class="sc">^-</span><span class="fu">depth</span>(c) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">2</span><span class="sc">^-</span>(<span class="fu">len</span>(c, a) <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">-</span> <span class="dv">2</span><span class="sc">^-</span>(<span class="fu">len</span>(c, b) <span class="sc">+</span> <span class="dv">1</span>))</span></code></pre><p></p></div>
<p>And the final similarity is <code>1 - distance</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="dv">2</span><span class="sc">^-</span><span class="fu">depth</span>(c) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">2</span><span class="sc">^-</span>(<span class="fu">len</span>(c, a) <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">-</span> <span class="dv">2</span><span class="sc">^-</span>(<span class="fu">len</span>(c, b) <span class="sc">+</span> <span class="dv">1</span>))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1007/3-540-45483-7_8" class="external-link">doi:10.1007/3-540-45483-7_8</a>
.</p>
<p>There is a parameter <code>depth_via_LCA</code> that can be set to <code>TRUE</code> or <code>FALSE</code>. IF it is set to <code>TRUE</code>, <code>depth(a)</code> is re-defined
as should pass the LCA term <code>c</code>. If it is <code>FALSE</code>, it goes to the original similarity definition in the paper and note the
similarity might be negative.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Zhong_2002"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">depth_via_LCA =</span> <span class="cn">FALSE</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-almubaid-">Sim_AlMubaid_2006<a class="anchor" aria-label="anchor" href="#sim-almubaid-"></a></h3>


<p>It also takes accout of the distance between term <code>a</code> and <code>b</code>, and the depth of the LCA term <code>c</code> in the DAG.
The distance is calculated as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(a, b) <span class="ot">=</span> <span class="fu">log</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">d</span>(a, b)<span class="sc">*</span>(max_depth <span class="sc">-</span> <span class="fu">depth</span>(c)))</span></code></pre><p></p></div>
<p>Here <code>d(a, b)</code> can be the shortest distance between <code>a</code> and <code>b</code> or the longst distance via LCA <code>c</code>.</p>
<p>Then the distance is transformed into the similarity value scaled by the possible maximal and minimal values of <code>D(a, b)</code> from the DAG:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>D_max <span class="ot">=</span> <span class="fu">log</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="dv">2</span><span class="sc">*</span>max_depth <span class="sc">*</span> max_depth)</span></code></pre><p></p></div>
<p>And the minimal value of <code>D(a, b)</code> is zero when <code>a</code> is identical to <code>b</code>. Then the similarity value is scaled as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">D</span>(a, b)<span class="sc">/</span>D_max</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1109/IEMBS.2006.259235" class="external-link">doi:10.1109/IEMBS.2006.259235</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_AlMubaid_2006"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-li-">Sim_Li_2003<a class="anchor" aria-label="anchor" href="#sim-li-"></a></h3>


<p>It is similar to the <em>Sim_AlMubaid_2006</em> method, but uses a non-linear form:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="fu">exp</span>(<span class="fl">0.2</span><span class="sc">*</span><span class="fu">d</span>(a, b)) <span class="sc">*</span> <span class="fu">atan</span>(<span class="fl">0.6</span><span class="sc">*</span><span class="fu">depth</span>(c))</span></code></pre><p></p></div>
<p>where <code>d(a, b)</code> can be the shortest distance or the longest distance via LCA.</p>
<p>Paper link: <a href="https://doi.org/10.1109/TKDE.2003.1209005" class="external-link">doi:10.1109/TKDE.2003.1209005</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Li_2003"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-rss-">Sim_RSS_2013<a class="anchor" aria-label="anchor" href="#sim-rss-"></a></h3>


<p>The similarity is adjusted by the positions of term <code>a</code>, <code>b</code> and the LCA term <code>c</code> in the DAG. The similarity is defined as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> max_depth<span class="sc">/</span>(max_depth <span class="sc">+</span> <span class="fu">d</span>(a, b)) <span class="sc">*</span> alpha<span class="sc">/</span>(alpha <span class="sc">+</span> beta)</span></code></pre><p></p></div>
<p>where <code>d(a, b)</code> is the distance between <code>a</code> and <code>b</code> which can be the shortest distance or the longest distance via LCA.</p>
<p>In the tuning factor, <code>alpha</code> is the distance of LCA to root, which is <code>depth(c)</code>. <code>beta</code> is the distance to leaves, which
is the minimal distance (or the minimal height) of term <code>a</code> and <code>b</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>alpha<span class="sc">/</span>(alpha <span class="sc">+</span> beta) <span class="ot">=</span> <span class="fu">depth</span>(c)<span class="sc">/</span>(<span class="fu">depth</span>(c) <span class="sc">+</span> <span class="fu">min</span>(<span class="fu">height</span>(a), <span class="fu">height</span>(b)))</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1371/journal.pone.0066745" class="external-link">doi:10.1371/journal.pone.0066745</a>
.</p>
<p>There is a parameter <code>distance</code> which takes value of "longest_distances_via_LCA" (the default) or "shortest_distances_via_NCA":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_RSS_2013"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">distance =</span> <span class="st">"shortest_distances_via_NCA"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-hrss-">Sim_HRSS_2013<a class="anchor" aria-label="anchor" href="#sim-hrss-"></a></h3>


<p>It is similar as the <em>Sim_RSS_2013</em> method, but it uses information content instead of the distance to adjust the similarity.</p>
<p>It first defines the semantic distance between term <code>a</code> and <code>b</code> as the sum of the distance to their MICA term <code>c</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(a, b) <span class="ot">=</span> <span class="fu">D</span>(c, a) <span class="sc">+</span> <span class="fu">D</span>(c, b)</span></code></pre><p></p></div>
<p>And the distance between an ancestor to a term is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(c, a) <span class="ot">=</span> <span class="fu">IC</span>(a) <span class="sc">-</span> <span class="fu">IC</span>(c)  <span class="co"># if c is an ancestor of a</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(a, b) <span class="ot">=</span> <span class="fu">D</span>(c, a) <span class="sc">+</span> <span class="fu">D</span>(c, b) <span class="ot">=</span> <span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b) <span class="sc">-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC</span>(c) <span class="co"># if c is the MICA of a and b</span></span></code></pre><p></p></div>
<p>Similarly, the similarity is also corrected by the position of MICA term and <code>a</code> and <code>b</code> in the DAG:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">D</span>(a, b)) <span class="sc">*</span> alpha<span class="sc">/</span>(alph <span class="sc">+</span> beta)</span></code></pre><p></p></div>
<p>Now <code>alpha</code> is the IC of the MICA term:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fu">IC</span>(c)</span></code></pre><p></p></div>
<p>And <code>beta</code> is the average of the maximal semantic distance of <code>a</code> and <code>b</code> to leaves.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>beta <span class="ot">=</span> <span class="fl">0.5</span><span class="sc">*</span>(<span class="fu">IC</span>(l_a) <span class="sc">-</span> <span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(l_b) <span class="sc">-</span> <span class="fu">IC</span>(b))</span></code></pre><p></p></div>
<p>where <code>l_a</code> is the leaf that <code>a</code> can reach with the highest IC (i.e. most informative leaf), and so is <code>l_b</code>.</p>
<p>Paper link: <a href="https://doi.org/10.1371/journal.pone.0066745" class="external-link">doi:10.1371/journal.pone.0066745</a>
.</p>
</div>


<div class="section">
<h3 id="sim-shen-">Sim_Shen_2010<a class="anchor" aria-label="anchor" href="#sim-shen-"></a></h3>


<p>It is based on the information content of terms on the path connecting term <code>a</code> and <code>b</code> via their MICA term <code>c</code>.</p>
<p>Denote a list of terms <code>a, ..., c, ..., b</code> which are composed by the shortest path from <code>a</code> to <code>c</code> and from <code>b</code> to <code>c</code>, the difference
between <code>a</code> and <code>b</code> is the sum of <code>1/IC</code> of the terms on the path:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sum_{x <span class="cf">in</span> the path}(<span class="dv">1</span><span class="sc">/</span><span class="fu">IC</span>(x))</span></code></pre><p></p></div>
<p>Then the distance is scaled into <code>[0, 1]</code> by an arctangent tarnsformation:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">atan</span>(sum_{x <span class="cf">in</span> the path}(<span class="dv">1</span><span class="sc">/</span><span class="fu">IC</span>(x)))<span class="sc">/</span>(pi<span class="sc">/</span><span class="dv">2</span>)</span></code></pre><p></p></div>
<p>And finally the similarity is:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">atan</span>(sum_{x <span class="cf">in</span> the path}(<span class="dv">1</span><span class="sc">/</span><span class="fu">IC</span>(x)))<span class="sc">/</span>(pi<span class="sc">/</span><span class="dv">2</span>)</span></code></pre><p></p></div>
<p>Paper link: <a href="https://doi.org/10.1109/BIBM.2010.5706623" class="external-link">doi:10.1109/BIBM.2010.5706623</a>
.</p>
</div>


<div class="section">
<h3 id="sim-ssdd-">Sim_SSDD_2013<a class="anchor" aria-label="anchor" href="#sim-ssdd-"></a></h3>


<p>It is similar as the <em>Sim_Shen_2010</em> which also sums content along the path passing through LCA term.
Instead of summing the information content, the <em>Sim_SSDD_2013</em> sums up a so-called "T-value":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">atan</span>(sum_{x <span class="cf">in</span> the path}(<span class="fu">T</span>(x)))<span class="sc">/</span>(pi<span class="sc">/</span><span class="dv">2</span>)</span></code></pre><p></p></div>
<p>Each term has a T-value and it measures the semantic content a term averagely inherited from its parents
and distributed to its offsprings. The T-value of root is 1. Assume a term <code>t</code> has two parents <code>p1</code> and <code>p1</code>,
The T-value for term <code>t</code> is averaged from its</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(w1<span class="sc">*</span><span class="fu">T</span>(p1) <span class="sc">+</span> w2<span class="sc">*</span><span class="fu">T</span>(p2))<span class="sc">/</span><span class="dv">2</span></span></code></pre><p></p></div>
<p>Since the parent may have other child terms, a factor <code>w1</code> or <code>w2</code> is multiplied to <code>T(p1)</code> and <code>T(p2)</code>. Taking
<code>p1</code> as an example, it has <code>n_p</code> offsprings (including itself) and <code>t</code> has <code>n_t</code> offsprings (including itself),
this means <code>n_t/n_p</code> of information is transmitted from <code>p1</code> to downstream via <code>t</code>, thus <code>w1</code> is defined as <code>n_t/n_p</code>.</p>
<p>Paper link: <a href="https://doi.org/10.1016/j.ygeno.2013.04.010" class="external-link">doi:10.1016/j.ygeno.2013.04.010</a>
.</p>
</div>


<div class="section">
<h3 id="sim-jiang-">Sim_Jiang_1997<a class="anchor" aria-label="anchor" href="#sim-jiang-"></a></h3>


<p>First semantic distance between term <code>a</code> and <code>b</code> via MICA term <code>c</code> is defined as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D</span>(a, b) <span class="ot">=</span> <span class="fu">IC</span>(a) <span class="sc">+</span> <span class="fu">IC</span>(b) <span class="sc">-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">IC</span>(c)</span></code></pre><p></p></div>
<p>Then there are several normalization method to change the distance to similarity and to scale it into the range of <code>[0, 1]</code>.</p><ul><li><p>max: <code>1 - D(a, b)/2/IC_max</code></p></li>
<li><p>Couto: <code>min(1, D(a, b)/IC_max)</code></p></li>
<li><p>Lin: <code>1 - D(a, b)/(IC(a) + IC(b))</code> which is the same as the <em>Sim_Lin_1998</em> method</p></li>
<li><p>Garla: <code>1 - log(D(a, b) + 1)/log(2*IC_max + 1)</code></p></li>
<li><p>log-Lin: <code>1 - log(D(a, b) + 1)/log(IC(a) + IC(b) + 1)</code></p></li>
<li><p>Rada: <code>1/(1 + D(a, b))</code></p></li>
</ul><p>Paper link: <a href="https://aclanthology.org/O97-1002/" class="external-link">https://aclanthology.org/O97-1002/</a>.</p>
<p>There is a parameter <code>norm_method</code> which takes value in "max", "Couto", "Lin", "Carla", "log-Lin", "Rada":</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Jiang_1997"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">norm_method =</span> <span class="st">"Lin"</span>))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-kappa">Sim_Kappa<a class="anchor" aria-label="anchor" href="#sim-kappa"></a></h3>


<p>Denote two sets <code>A</code> and <code>B</code> as the items annotated to term <code>a</code> and <code>b</code>. The similarity value is <a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa" class="external-link">the kappa coeffcient</a>
of the two sets.</p>
<p>The universe or the background can be set via parameter <code>anno_universe</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_kappa"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">anno_universe =</span> ...))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-jaccard">Sim_Jaccard<a class="anchor" aria-label="anchor" href="#sim-jaccard"></a></h3>


<p>Denote two sets <code>A</code> and <code>B</code> as the items annotated to term <code>a</code> and <code>b</code>. The similarity value is the Jaccard coeffcient
of the two sets, defined as <code>length(intersect(A, B))/length(union(A, B))</code>.</p>
<p>The universe or the background can be set via parameter <code>anno_universe</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Jaccard"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">anno_universe =</span> ...))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-dice">Sim_Dice<a class="anchor" aria-label="anchor" href="#sim-dice"></a></h3>


<p>Denote two sets <code>A</code> and <code>B</code> as the items annotated to term <code>a</code> and <code>b</code>. The similarity value is the Dice coeffcient
of the two sets, defined as <code>2*length(intersect(A, B))/(length(A) + length(B))</code>.</p>
<p>The universe or the background can be set via parameter <code>anno_universe</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Dice"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">anno_universe =</span> ...))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-overlap">Sim_Overlap<a class="anchor" aria-label="anchor" href="#sim-overlap"></a></h3>


<p>Denote two sets <code>A</code> and <code>B</code> as the items annotated to term <code>a</code> and <code>b</code>. The similarity value is the overlap coeffcient
of the two sets, defined as <code>length(intersect(A, B))/min(length(A), length(B))</code>.</p>
<p>The universe or the background can be set via parameter <code>anno_universe</code>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Overlap"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">anno_universe =</span> ...))</span></code></pre><p></p></div>
</div>


<div class="section">
<h3 id="sim-ancestor">Sim_Ancestor<a class="anchor" aria-label="anchor" href="#sim-ancestor"></a></h3>


<p>Denote <code>S_a</code> and <code>S_b</code> are two sets of ancestor terms of term <code>a</code> and <code>b</code> (including <code>a</code> and <code>b</code>), the
semantic similarity is defined as:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(<span class="fu">intersect</span>(S_a, S_b))<span class="sc">/</span><span class="fu">length</span>(<span class="fu">union</span>(S_a, S_b))</span></code></pre><p></p></div>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">term_sim</span>(dag, terms, <span class="at">method =</span> <span class="st">"Sim_Ancestor"</span>)</span></code></pre><p></p></div>
</div>

    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="va">parents</span>  <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">children</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>, <span class="st">"f"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">annotation</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>    <span class="st">"a"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,</span></span>
<span class="r-in"><span>    <span class="st">"b"</span> <span class="op">=</span> <span class="fl">3</span><span class="op">:</span><span class="fl">4</span>,</span></span>
<span class="r-in"><span>    <span class="st">"c"</span> <span class="op">=</span> <span class="fl">5</span>,</span></span>
<span class="r-in"><span>    <span class="st">"d"</span> <span class="op">=</span> <span class="fl">7</span>,</span></span>
<span class="r-in"><span>    <span class="st">"e"</span> <span class="op">=</span> <span class="fl">4</span><span class="op">:</span><span class="fl">7</span>,</span></span>
<span class="r-in"><span>    <span class="st">"f"</span> <span class="op">=</span> <span class="fl">8</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dag</span> <span class="op">=</span> <span class="fu"><a href="create_ontology_DAG.html">create_ontology_DAG</a></span><span class="op">(</span><span class="va">parents</span>, <span class="va">children</span>, annotation <span class="op">=</span> <span class="va">annotation</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">term_sim</span><span class="op">(</span><span class="va">dag</span>, <span class="fu"><a href="dag_all_terms.html">dag_all_terms</a></span><span class="op">(</span><span class="va">dag</span><span class="op">)</span>, method <span class="op">=</span> <span class="st">"Sim_Lin_1998"</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> term_sim_method: Sim_Lin_1998</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> IC_method: IC_annotation</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> collecting all ancestors of input terms ...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> going through 0 / 6 ancestors ...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> going through 6 / 6 ancestors ... Done.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   a         b         c         d         e         f</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a 1 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> b 0 1.0000000 0.5866099 0.3437110 0.5866099 0.2430647</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> c 0 0.5866099 1.0000000 0.2766917 1.0000000 0.2075187</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d 0 0.3437110 0.2766917 1.0000000 0.2766917 0.8000000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> e 0 0.5866099 1.0000000 0.2766917 1.0000000 0.2075187</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> f 0 0.2430647 0.2075187 0.8000000 0.2075187 1.0000000</span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Zuguang Gu.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

